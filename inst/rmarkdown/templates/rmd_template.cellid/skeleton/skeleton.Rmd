---
title: "rcell2.cellid: CellID Workflow Template"
author: "Nicolás Méndez"
output:
  html_document:
    df_print: paged
    toc: yes
    toc_float:
      collapsed: false
    toc_depth: 4
    number_sections: false
    smooth_scroll: false
    code_folding: show  # hide
    code_download: true
    highlight: breezedark # pygments # tango
    theme: "darkly"
  pdf_document:
    latex_engine: xelatex
    toc: true
    toc_depth: 4
    number_sections: true
editor_options:
  chunk_output_type: inline
date: "`r format(Sys.time(), '%d %B, %Y')`"
urlcolor: blue
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "output/renders") })
# bibliography: references.bib
---

<!-- Download a copy of this file with rcell2.cellid::get_workflow_template_cellid() -->

```{r setup, include=FALSE}
# Set chunk options
knitr::opts_chunk$set(echo = T, message = F, out.width = "100%", eval = F,
                      # https://stackoverflow.com/a/15081230
                      comment=NA)
                      # https://yihui.org/knitr/options/#chunk-options
                      # https://stackoverflow.com/a/66753995
                      # tidy.opts = list(width.cutoff = 60), tidy = TRUE)
# Remove comments from printed text (https://stackoverflow.com/a/44729363)
# knitr::opts_chunk$set(tidy = TRUE, 
#                       tidy.opts = list(comment = FALSE))


# Set knit options
knitr::opts_knit$set(root.dir = here::here())

library(rcell2.cellid)    # Run CellID entirely in R.
# library(rcell2)         # Load Cell-ID's output
# library(rcell2.magick)  # Filter data using Shiny and preview images with Magick.

library(tidyverse)  # import numpy as np (?)
# library(magick)  # if you need it
```

# Introduction

This notebook contains a minimal [Example workflow], with a broad overview of the pipeline,
and a [Full usage guide] with in-depth explanations and advanced usage examples.

## Friendly reminder

- **Read this notebook carefully**.
- Use the **help page** of functions before using them. Open help pages with R's `?` (e.g. `?arguments`).
- Read the README.md at rcell2's [GitHub repo](https://github.com/darksideoftheshmoo/rcell2/).

## Example workflow

This is only meant as a quick example.

For full usage details, skip to the [Full usage guide] section of this notebook, 
and read it carefully.

Always read the `?help` before using a function ;) specially when they do file operations,
which are irreversible.

This example uses:

* Image examples from the `rcell2.examples` package.
* Images and filenames in time-course experiment "format": `BF_Position001_time01.tif`
* Default CellID segmentation parameters.
* The built-in CellID binary.

### Images directory

First point R to the folder containing the images. This notebook obeys the path
specified in the `data.dir` variable. Make sure to assign its value once, or 
double-check before overwriting it.

In this example we install and use a set from the "examples" package. A more
detailed explanation is available in the [Path to the dataset] section of
this notebook.

```{r}
if(!requireNamespace("remotes")){
  # Install the "remotes" package if not found:
  install.packages("remotes")
}

if(!requireNamespace("rcell2.examples")){
  # Install the "rcell2.examples" package if not found:
  remotes::install_github("darksideoftheshmoo/rcell2.examples")
}

# Example: Choose one set of example images:
data.dir <- system.file("extdata/sample_datasets/sample_time_series/",
                        package = "rcell2.examples")
# List image files in the set:
dir(data.dir)
```

### Naming images for Cell-ID

Images output by the acquisition software may result in file
names different from the default style (i.e `YFP_Position01_time1.tif`, and so on).
The default pattern is described at the [Image file names] section of this notebook.

The `rename_mda` function will help you rename file names to match that pattern.
The function is provided by the `rcell2.cellid` package. A full example on how to
use it is available below, in the [Renaming images] section of this notebook.

### Run Cell-ID

1. Customize parameters for CellID.

```{r}
# Create a list of parameters with default values.
parameters.list <- rcell2.cellid::parameters_default()

# Write the parameters to a plain-text file, and save its path.
parameters.txt <- rcell2.cellid::parameters_write(parameters.list)
```

> Note: segmentation parameters for Cell-ID and criteria to customize them
> are discussed in the [Parameters] section of this notebook.

2. Prepare the "arguments" dataframe for CellID, which lists the image files that match
   the regular expression specified in `file.pattern`.

```{r}
# Gather images
cellid.args <- 
  rcell2.cellid::arguments(path = data.dir, 
                           parameters = parameters.txt)
```

> Note: the default file pattern will match file names that match de default pattern
> (described in the [Image file names] section). Alternative patterns are discussed
> in the [Arguments] section.

3. Run Cell-ID with the built-in executable:

```{r eval=F}
cell2.out <- 
  rcell2.cellid::cell2(arguments = cellid.args,
                       # progress = T,  # Progress bar (requires doSnow).
                       # cell.command = "~/Software/cellID-linux/cell",  # You may use an external executable.
                       output_coords_to_tsv = T  # Optional! Only works with newer CellID (>= 1.5).
                       )

# Check the output messages:
cell2.out
```

> Note: we suggest that you check your images before segmentation, as shown in the
> [Preview images in ImageJ] section. It may be critical to optimize parameters on a subset of 
> images, before processing the whole experiment, as shown in the [Tuning parameters] 
> section.

### Load the output

The output tables can be loaded with `get_cell_data` provided by this package.

```{r eval=F}
# Load output
cell.data <- get_cell_data(path = data.dir)
```

> Note: detailed usage of this function is described at the [Output data] section of this
> notebook.

`rcell2.cellid` can also load the cell boundaries and interior pixels coordinates,
if either `output_coords_to_tsv` or `encode_cellID_in_pixels` were set to `TRUE`
when Cell-ID was run.

To load the boundary pixels, use the `cell.load.boundaries`:

```{r eval=F}
# Useful if either "output_coords_to_tsv" or "encode_cellID_in_pixels" were TRUE in cell().
cell.boundaries <- 
  cell.load.boundaries(data.source = "masks.tsv",
                       positions = cell.data$positions,
                       pixel.type = "b")
```

> This data is only available if `cell2` was run with `output_coords_to_tsv = T`.

> Note: `rcell2` provides the `load_cell_data` and `cell.load.boundaries` functions,
> to load the measurements and cell boundary pixels, respectively.

### Understanding the data

Access the main output data and plot:

```{r}
cdata <- cell.data$data

cdata %>% ggplot(aes(a.tot, fft.stat)) + 
  geom_point() + facet_grid(t.frame~pos)
```

> Note: the "c" in "cdata" stands for _cell_ data.

Output variables are described by this documentation function:

```{r}
rcell2.cellid::cellid_output_descriptions(list.output = F)
```

Plot cell boundaries:

```{r}
cell.boundaries %>% 
  group_by(pos) %>% filter(cellID == 0) %>% 
  filter(pixtype == "b") %>% 
  ggplot(aes(x,y,color=factor(t.frame)))+
  geom_path()+
  facet_wrap(~pos, scales = "free") + theme(aspect.ratio = 1)
```

> This data is only available if `cell2` has been run with `output_coords_to_tsv = T`.

### Load position metadata

This step is optional, but also part of our usual workflow.

The `pdata` CSV file holds information about how the cells
of each position (and time) were prepared and treated.

Get the path to the file:

```{r}
# pdata_path <- "path/to/your/pdata.csv"
pdata_path <- dir(data.dir, "pdata.csv", full.names = T)  # Sample pdata

pdata_path
```

Load "pdata":

```{r}
# It is a "metadata" dataframe we usually join to cdata by "position" and/or "t.frame",
# which contains other experimental variables: simuli concentrations, notes, etc.
pdata <- readr::read_csv(pdata_path)

pdata
```

> Note: the "p" in "pdata" stands for microscope _position_ data.

This table is usually joined to cdata by position (and time frame if available).

> Warning: `load_cell_data` does the following automatically if a pdata.csv file is found next to the images.
> If it were the case, you shouldn't run the join again.

```{r eval=F}
cdata <- left_join(cdata, pdata)
```

### Save and restore progress

We recommend saving the current state at this point.

```{r eval=F}
# Save all variables to a Rdata file.
save.image("01-segmentation_results.Rdata")
```

The workspace image may be restored later on:

```{r eval=F}
# Restore all variables from the Rdata file.
load("01-segmentation_results.Rdata")
```

### Advanced tools

You may want to check out the Shiny/Magick rcell2 analisys package!

It provides functions to manipulate images of single cells into strips, mosaics,
and plots. It has it's own notebook with full examples and explanations.

Execute the following to install the package.

```{r eval=F}
if(!requireNamespace("rcell2.magick")) remotes::install_github("darksideoftheshmoo/rcell2-magick")
```

Run the following to open package's notebook:

```{r}
rcell2.magick::get_workflow_template_magick()
```

Alternatively, run the following line-by-line, to preview its features.

```{r eval=F}
# Images data.frame
images <- cell.data$images

# Pics
cdata %>% filter(fft.stat < 0.3, el.p > 0.8) %>% 
  rcell2.magick::magickCell(images)

# Plot
rcell2.magick::cellSpreadPlot(cdata, images)

# App
rcell2.magick::shinyCell(cdata, paths = images)
```

# Full usage guide

This section has detailed explanations and usage examples of the tools in `rcell2.cellid`.

## Path to the dataset

First point R to the folder containing the images. This notebook obeys the path
specified in the `data.dir` variable. Make sure to assign its value once, or 
double-check before overwriting it.

### Use yours

If you already have an appropriate dataset, specify the path to the images like this:

> Note: the aprropriate pattern for file names is described at the [Image file names]
> section of this notebook.

```{r}
# Location of your image set
data.dir <- "/path/to/your/data"

# R has an interactive file chooser
data.dir <- dirname(file.choose())
```

### Use the examples

Otherwise, install and use the "examples" package, which provides example images and scripts.

First, get the example data:

```{r}
if(!requireNamespace("remotes")){
  # Install the "remotes" package if not found:
  install.packages("remotes")
}

if(!requireNamespace("rcell2.examples")){
  # Install the "rcell2.examples" package if not found:
  remotes::install_github("darksideoftheshmoo/rcell2.examples")
}

# List available datasets:
dir(system.file("extdata/sample_datasets/", package = "rcell2.examples"))
```

Second, get the path to the chosen example dataset and check if the files are there:

> The dataset selected in the chunk below is a subset of a larger experiment.
> The subset contains two positions (4, 12), three time frames (10, 20, 30),
> three 'fluorescence' channels (TFP, YFP), and the mandatory BF channel.

```{r}
# Example: Choose one set of example images:
data.dir <- system.file("extdata/sample_datasets/sample_time_series/",
                        package = "rcell2.examples")
```

> In the chunk above we set up `data.dir` to hold the path to samples images of a
time-course experiment. This will replace any previous value!

Finally, check if the files are there:

```{r}
# List image files in the set:
dir(data.dir)
```

## Image file names

Images are assumed to be in a single directory, and have names with identifiers for:

* Imaging channel (bright field, transmission, fluorescence, z-slice, etc.).
* Microscope position (*pos*).
* Time (*t.frame*, optional).

Cell-ID uses the first 3 letters of the file name to group imaging channels.
**This is mandatory**. If your image set does not conform initially, it can be
renamed (or symlinked) using rcell2's `rename_mda`, with custom arguments.

For example, file names for a 2-position time course experiment
are expected to have the following appearance:

```
BF_Position001_time01.tif
BF_Position001_time02.tif
TFP_Position001_time01.tif
TFP_Position001_time02.tif
YFP_Position001_time01.tif
YFP_Position001_time02.tif
BF_Position002_time01.tif
BF_Position002_time02.tif
TFP_Position002_time01.tif
TFP_Position002_time02.tif
YFP_Position002_time01.tif
YFP_Position002_time02.tif
```

The `rcell2` packages rely on regular expressions to gather images and extract 
metadata from their file names (i.e. channel, position, and time frame.)

The file list will be recognized by a specific regular expression (regex).
A regex matching these files can be `^(BF|TFP)_Position(\\d+)_time(\\d+).tif$`;
note that it has **3 capturing groups** (suff between parentheses).
The regex as a whole is used to select images from a directory (filtering out
other files) and the capturing groups are used to extract the metadata.

### Renaming images

Metamorph's _Multi-dimensional acquisition_ (MDA for short) may use file 
names different from the usual style (i.e `far6_w2LED-BF--YFPcube--cam_s7_t2.TIF` 
instead of `BF_Position07_time02.tif`, and so on).

The `rename_mda` function renames those files names, making them compatible
with `rcell2`'s defaults. See `?rename_mda` for extra options.

The defaults are useful for a three channel experiment, 
and file names looking like this: `far6_w2LED-BF--YFPcube--cam_s7_t2.TIF`.

#### Preview

A preview of how files will be renamed can be generated:

```{r}
# Choose a sample file name (one or many)
one.filename <- "far6_w2LED-BF--YFPcube--cam_s7_t2.TIF"

# Pass it to rename_mda, setting rename.function to NULL (to avoid actually copying files).
result <- rename_mda(rename.function = NULL, 
                     file.names = one.filename)

# Get the info we're interested in
result$status %>% select(file, rename.file)
```

A "renaming data frame" (`images.info` below) can be extracted and examined before renaming all images:

```{r}
# Set rename.function to NULL (to avoid actually copying files).
images.info <- 
  rename_mda(rename.function = NULL, 
             rename.dataframe = TRUE,
             file.names = one.filename)

images.info
```

The updated `images.info` data frame can also be adjusted and then used to rename images:

```{r}
# Example: adjust "t.frame".
images.info <- images.info |> mutate(t.frame = 99)

# Pass the updated data.frame to the "rename.dataframe" argument.
# Set rename.function to NULL (to avoid actually copying files for now).
images.info.final <- 
  rename_mda(rename.function = NULL, 
             rename.dataframe = images.info,
             file.names = one.filename)

images.info.final
```

A _dummy_ example follows:

```{r}
# Path to the images produced by MetaMorph's MDA.
images.path <- file.path(tempdir(), "images")
# Create a temporary directory
dir.create(images.path)
# Create a dummy file
writeLines(text = "dummy content", 
           con = paste0(images.path, "far6_w2LED-BF--YFPcube--cam_s7_t2.TIF"))

# Rename files
rename_mda(images.path)
```

List all files in the images directory to inspect the result:

```{r}
dir(images.path, recursive = T)
```

#### Rename all

To run the function on all images, provide the path to the images directory.

```{r}
result <- rename_mda(images.path = data.dir)
```

Update the value of the `data.dir` variable:

```{r}
data.dir <- result[["rename.path"]]
```

The defaults are easily adaptable to other use cases. 
To use the function with different file name patterns, adjust `identifier.pattern`,
`identifier.info`, and `channel.maping.df`. See `?rename_mda` for details.

> Note that the `ch` field in `channel.maping.df` must match exactly the
> text captured by the channel group in the `identifier.pattern` regex.
> Read the function's help page for details: `?rename_mda`.

## Preprocessing

The following sections may help improve the result of the segmentation,
to catch severe issues early on.

### Check that your images are there

The `arguments` function will run several tests (using `arguments_check` internally)
before returning the list of images for Cell-ID.

Warnings (or errors if desired) will be generated if the checks fail.

You can also set `check_fail = FALSE` to inspect all warnings without raising an error.

```{r}
# Get images and their metadata.
image_list <- rcell2.cellid::arguments(data.dir, 
                                       check_fail = TRUE,
                                       file.pattern = "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$")
```

> Note: the usage of the "file.pattern" argument is explained at the
> [Arguments] section of this notebook.

Inspect the image list:

```{r}
View(image_list)
```

### Check XY stage coordinates

It may be a good idea to double check that the physical coordinates of your images
match your expectations (i.e. the column/row pairs of each well in a microscopy plate).
This information is stored in TIFF's metadata.

It requires the `ijtiff` and `XML` packages, install them by running the following:

```{r}
if(!requireNamespace("ijtiff")) install.packages("ijtiff")
if(!requireNamespace("XML")) install.packages("XML")
```

<!-- Internal note: The xml2 package does not convert the attributes automatically, 
so I stuck to the XML package. See tiff_plane_info's help and source for details. -->

#### Plot position overlaps

The following code match the images' _position_ (Pos) to their microscope stage _physical_ XY coordinates,
which are stored in the TIFF tags of the original images.

This plot is specially useful when tracing a path for positions in a multi-well time-course experiment.

It requires the `images` dataframe in `cell.data` to get the file names,
_but_ you could also use `dir` to get the files by pattern, and `sub` to get the position IDs,
independently of Cell-ID.

Optionally set details from your microscope (e.g. magnification and physical size of the camera's pixels).

```{r}
# Get images.
image_list <- rcell2.cellid::arguments(path = data.dir,
                                       file.pattern = "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$")

# Extract metadata and plot stage positions.
result <- plot_pos_overlaps(image_list, channels = "TFP")

# The plot can be found in the output list.
# result$plt
```

> If any two shaded areas overlap, there will be duplicated cells in the dataset.

We do not yet offer a way to remove them automatically. You may do this yourself
by finding the XY coordinates of the first cells not shared between images, and using
their coordinates to remove the overlapping set from one position.

### Preview images using ImageJ

No analysis package exists (yet) that can replace a researcher's general visual assessment.

This section helps you open your images with FIJI-ImageJ before you begin.

A simple Macro can be run in ImageJ to load virtual hyperstacks of any experiment.

> Note: this macro uses a "file" pattern that only matches input images (and not ".out")
> in a tipically-named set of images.

Steps:

1. Run the following code, copy its output to the clipboard.
2. Open ImageJ/FIJI, and open a new "Macro" window by clicking on "Plugins -> New -> Macro".
3. Paste the macro into the macro editor, and click on "Run". A new hyperstack window will open.
4. Browse the images using the sliders.

```{r}
# Get images and their metadata.
image_list <- rcell2.cellid::arguments(data.dir,
                                       file.pattern = "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$")

# Convert the "arguments" to a list of "images" required to make the ImageJ macro.
image_list |> 
  arguments_to_images() |>
  ijm_open_hyperstack(use_out = F)
```

> Note: the dimensions names may be mismatched between R and the macro if `fix_order=F`. 
> This is because virtual stacks must be in `xyczt` order (time is likely to end up as the "channels" dimension),
> but the order in which the "Image Sequence..." is loaded depends on how their files are named.

The only restriction of this approach is that only "3" dimensions are available for
browsing: `frame`, `plane`, and `channel`. This is relevant if you wish to browse
segmentation results (which adds another dimension to the set: "original" vs "out").
A fourth dimension would be needed, but Hyperstacks only provide 3. The default is to
load "out" files as new channels.

### Check acquisition times

Acquisition times can be extracted from metadata in the TIFF files produced by MetaMorph.

```{r}
# Get images.
image_list <- rcell2.cellid::arguments(path = data.dir,
                                       file.pattern = "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$") |> 
  suppressWarnings()
```

Extract time information for the BF channel only:

```{r}
time_info <- get_time_info(image_list = image_list, channels = "BF")
```

Distribution of time intervals:

```{r}
time_info |> filter(pos == first(pos)) |> 
  with(acquisition.time.ct) |>as.numeric() |> diff() |> 
  hist(main="Distribution of time interval between frames", 
       xlab="Interval time (seconds)")
```

Time plotted against `t.frame` should be diagonal:

```{r}
time_info |> 
  ggplot(aes(acquisition.time.ct, t.frame)) +
  geom_line() + 
  facet_wrap(~pos)
```

> Note that ImageJ's FFT filter will not add MetaMorph's metadata to the filtered BFs.
> This means that `get_time_info` will only work on the original TIFF files.

### Apply FFT filter on BF images

Optionally, use ImageJ's band-pass FFT filter on the defocused bright field images.

This can help Cell-ID find cells and reduce background artifacts.

List the BF images from the `arguments` function:

```{r eval=F}
# Get image paths
cellid.args <-
  rcell2.cellid::arguments(path = data.dir,
                           file.pattern = "^(BF|[TRY]FP)_Position(\\d+)_time(\\d+).tif$")
```

The `run_fft_filter_on_bfs` will launch ImageJ in the background and apply the FFT filter on a copy of the images.

In brief, it will:

- Split the BF files by position, and symlink them to different subdirectories.
- Run FFT filter in parallel using a macro, with one ImageJ instance per subdirectory.
- Symlink filtered BFs from each subdirectory to a single "filtered" images directory.
- Symlink the rest of the images (i.e. fluorescence images) to the "filtered" directory.

Run the filter:

```{r eval=F}
new.data.dir <- run_fft_filter_on_bfs(
  data.dir = data.dir,
  cellid.args = cellid.args,
  imagej.path="~/Software/ImageJ/Fiji.app/ImageJ-linux64") # Adjust to your system

new.data.dir
```

You can run Cell-ID using the new directory as the new `data.dir`:

```{r eval=F}
data.dir <- normalizePath(new.data.dir)
```

## Segmentation

In this section we will prepare and run Cell-ID.

### Parameters

First we must configure the Cell-ID parameters that affect cell segmentation, 
tracking, and some corrections.

#### Descriptions

Show a data.frame with the description of each Cell-ID parameter:

```{r}
rcell2.cellid::cellid_parameter_descriptions(list_format = F)
```

#### Example parameter set

`parameters_default` is a helper function to prepare parameters more easily:

```{r}
parameters.list <- 
  rcell2.cellid::parameters_default(background_reject_factor = 0.8)

parameters.list$max_split_over_minor
```

Parameters must be written to a `parameters.txt` plain text file with the proper syntax,
which Cell-ID will read later on.

For this purpose, you may use the `parameters_write()` function. It writes the parameters,
and returns the path where it was saved.

<!-- Internal note: consider moving this step into cell2() -->
```{r}
parameters.txt <- rcell2.cellid::parameters_write(parameters.list)

parameters.txt
```

Este path es el que hay que pasarle a `arguments()` en la siguiente sección.

Revisemos el contenido del `parameters.txt` que generamos recién:

```{r}
# Mostrar el contenido del archivo
writeLines(readLines(parameters.txt))
```

For clarity, here is a valid, hand-made parameter list, with the same defaults:

```{r eval=F}
parameters.list <- list(
  max_split_over_minor = 0.50,
  max_dist_over_waist = 8.00,
  max_pixels_per_cell = 2000,
  min_pixels_per_cell = 75,
  background_reject_factor = 0.75,
  tracking_comparison = 0.20,
  align_individual_cells = F,
  align_fl_to_bf = T,
  image_type = "brightfield",
  bf_fl_mapping = "list"
  )
```

### Arguments

The `arguments` function outputs a data.frame with information from images, 
which is needed to run Cell-ID.

The key parameter is `file.pattern`, a regular expression used to find image
files in the `data.dir` path.

By default, `arguments` uses:

    "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$"

Enclosed in parentheses are the "capture groups" of the regular expression.
These delimit the parts of the file name which contain identifiers for 

1. Imaging channel (`ch`).
2. Stage position index (`pos`).
3. Time-frame index (`t.frame`).

If your experiment has a single time frame, and it is not part of the file names,
the content of the corresponding capturing group can be deleted (leaving the
empty parentesis in place):

    "^(BF|[A-Z]FP)_Position(\\d+)().tif$"

The regular expression can be used to select or filter out sets of images (
though it will be often easier to use R's tool for this). To select only position
with index "2", and times 2, 3 and 4, use:

    "^(BF|[A-Z]FP)_Position(0*2)_time(0*[423]).tif$"

> Note the `0*` in front of numbers. This indicates that there might me be leading
> zeros in front of the position and time identifiers.

If the identifiers on your file names appear in a different order, either rename them as
shown in the [Renaming images] section, or reorder the default `file.pattern.groups.order`
in the call to `arguments`.

Note, however, that the channel identifier _must_ be first. Cell-ID will use the **first
three letters** to distinguish and group imaging channels.

#### Input file pattern

Adjust file patterns in `rcell2.cellid::arguments`. Go through the function's
help page to learn about its parameters.

The path to the images of your experiment must be alredy defined,
as explained in the [Path to the dataset] section of this notebook.

> **Important**: the patterns used in `arguments` must match the ones used in
> `get_cell_data` when loading Cell-ID's output (later on).

Original images file pattern examples; choose one and comment the others:

```{r}
# Default value: all channels, no z-stack.
arguments.file.pattern <- "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$"

# To consider z-stacks:
# arguments.file.pattern <- "^(BF|[A-Z]\d+)_Position(\d+)_time(\d+).tif$"

# BF or TFP only, no t.frame info.
# arguments.file.pattern <- "^(BF|TFP)_Position(\\d+)().tif$"
```

#### Usage example

Check that image file names are properly recognized:

```{r}
cellid.args <- rcell2.cellid::arguments(data.dir,
                                        file.pattern = arguments.file.pattern,
                                        parameters = parameters.txt)  # Parameters are specified here.

cellid.args
```

You can filter out or select certain image sets at this stage:

```{r}
cellid.args %>% filter(pos == 2, t.frame %in% c(4,2,3))
```

#### Nuclear or Vacuolar tags

Images containing the location of the nucleus or vacuole can be used
to derive extra measurements from those structures.

A "third" image list must be added to the arguments. In the following example,
the YPF channel is added to the arguments to a new column named "`third`" exactly.

```{r}
# Optionally Add "third" column
cellid.args <-  left_join(
  cellid.args,
  cellid.args %>% filter(ch == "YFP") %>% select(pos, t.frame, image) %>% rename(third = image)
)
```

The `cell2` function will look for this column and pass the images to Cell-ID if found.

To enable this feature in Cell-ID, the parameters must have been 
also configured (see `?parameters_default`) by setting `third_image` to
"vacuole_label" or "nuclear_label".

### Tuning parameters

Sometimes we want to test out many parameter combinations 
before running Cell-ID in the full dataset.

> If you use Cell-ID often, your cells' morphologies do not change dramatically,
> and you are using the same microscope as the last time, you may be better off 
> reusing those parameters and skipping this section.

This functionality requires the `magick` R package,
and ImageMagick on your system (which can be obtained 
[here](https://imagemagick.org/script/download.php)). 

Run the following to install the R package if absent:

```{r}
if(!requireNamespace("magick")){
  install.packages("magick")
}
```

#### Example setup

Define working paths for parameter testing:

* `data.dir`: directory with the original images (they will not be modified).
* `test.dir`: directory for temporary files of the tuning process.

```{r}
# Set your own path, or uncomment the following to use example images.
# data.dir <- system.file("extdata/sample_datasets/sample_time_series/",
#                         package = "rcell2.examples")

# The output of the parameter scan will be saved here:
test.dir <- file.path(tempdir(), "images_directory", "test.dir")
test.dir
```

Setup arguments and patterns as usual (if not done already):

```{r}
# Default value: all channels, no z-stack.
arguments.file.pattern <- "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$"

# Get full image list
cellid.args <- rcell2.cellid::arguments(data.dir,
                                        file.pattern = arguments.file.pattern)
```

#### Image set

Choose which image sets in `cellid.args` you wish to use for the parameter scan.

For example, choose some *positions* (image sets) and *t.frame*s (time frames)
to restrict the image test set to only some of them.

```{r}
# Choose test positions, frames and channels.
test.pos = unique(cellid.args$pos)[1]        # e.g.: One position.
test.frames = unique(cellid.args$t.frame)[1] # e.g.: One frame.
test.chs = unique(cellid.args$ch)[1]         # e.g.: One channel.

# Filter cellid.args to choose image sets for the scan
scan.arguments <-  
  subset(cellid.args, 
         pos %in% test.pos & t.frame %in% test.frames & ch %in% test.chs)

# Examine the subset
scan.arguments
```

#### Parameter combinations

For each parameter variation, we need a new parameters file.

In this example, only `background_reject_factor` is scanned, across 4 values:

```{r}
parameters.list <- rcell2.cellid::parameters_default(
  background_reject_factor = seq(from=0, to=1.5, by = 0.4)
)

parameters.list$background_reject_factor
```

The parameters list must now be expanded into a data.frame, 
with a row for every possible combination of parameter values:

```{r}
parameters.df <- expand.grid(parameters.list)

parameters.df
```

> Note: You might want to select some rows from that table. In that case, simply filter it.

#### Automatic scan

> Now comes the magic part.

The `parameter_scan` function uses temporary directories to work on images, 
and avoids messing up the main data directory, 
while running CellID in parallel for each parameter variation.

Just run:

```{r eval=F}
scan.results <- 
  parameter_scan(parameters.df = parameters.df,
                 # Optionally choose the temporary output directory by setting "test.dir".
                 scan.arguments = scan.arguments)
```

> Have a look at the function's source code if you like, its hopefully well commented.

#### Plot summary

A few "summary" quantities are calculated for each run:

* `fft`
* `el.p`
* `ucids`
* `persistence`
* `roughness`
* `roughness2`

The average of these quantities may be useful for selecting optimal parameters.

A few of combinations these are plotted below.

First get the output dataframe:

```{r}
results.bound <- scan.results$results.bound
```

A few plots:

```{r}
results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(persistence, el.p/fft, label = id,
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. frames per cell (persistence) VS 'el.p/fft' per parameter variation") +
  theme_minimal() + scale_color_discrete()

results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(persistence, el.p/fft, label = id,
                 color = as.ordered(max_split_over_minor)),
             alpha = .7, fill = "NA") +
  ggtitle("Avg. frames per cell (persistence) VS 'el.p/fft' per parameter variation") +
  theme_minimal() + scale_color_discrete()
```

<!-- Internal note: TO-DO: add explanations of these quantitites. -->

More plots:

```{r}
results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(el.p, fft, label = id,
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. el.p VS Avg. fft.stat per parameter variation") +
  theme_minimal() + scale_color_discrete()

results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(roughness, persistence, label = paste0(id, "=", background_reject_factor),
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. roughness per cell VS Avg. frames per cell (persistence) per parameter variation") +
  theme_minimal() + scale_color_discrete()

results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(roughness2, persistence, label = paste0(id, "=", background_reject_factor),
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. roughness2 per cell VS Avg. frames per cell (persistence) per parameter variation") +
  theme_minimal() + scale_color_discrete()
```

<!-- Internal note: TO-DO: add explanations of these quantitites. -->

#### Review result in ImageJ

Prepare virtual TIFF stacks for a one or more imaging channels, with the `make_scan_stacks` function.

To help the user choose a parameter set, the stacks are annotated with the parameters used
for the segmentation, and other metadata (position, time frame, and channel).

There are two alternatives: `annotate_scan_output` and `make_scan_stacks`. The first will
annotate the images and save them, and the latter will annotate the images and save them
to a stack. Note that making a stack can consume all your system's RAM if the scan is 
moderately large. We recommend using `annotate_scan_output`.

A copy-paste-ready ImageJ Macro will be printed out by either function, 
to easily load the stacks as virtual Hyperstacks in ImageJ.

##### Option A: annotate_scan_output

```{r}
imagej_macros <- annotate_scan_output(scan.results = scan.results, 
                                      in.place = FALSE,
                                      preserve.source.imgs = TRUE,
                                      annotated.imgs.dir = "annotated",
                                      annotation.font = "Hack")
```

> Copy paste the macro to a new macro window in ImageJ, and hit run!
> The stack should be loaded auto-magically.

Macros are saved to the output.

##### Option B: make_scan_stacks

```{r eval=F}
stack.paths <- 
  make_scan_stacks(scan.results = scan.results, 
                   stack.channels = "BF.out")
```

> Have a look at the function's source code if you like, its hopefully well commented.

Paths and macros are saved in the output:

```{r}
names(stack.paths)
```

```{r}
stack.paths$stack.paths
```

```{r}
stack.paths$imagej.macros
```

#### Final parameter set

This parameter set was chosen for FFT-filtered BFs.

Under 0.8 background_reject_factor, there were some "persistent" _ghosts_;
elongated _chorizos_ on the sides of cells.

```{r eval=F}
parameters.list <- rcell2.cellid::parameters_default(
  background_reject_factor = 0.8,
  max_split_over_minor = 0.6,
  max_dist_over_waist = 6,
  max_pixels_per_cell = 3500,
  treat_brightfield_as_fluorescence_also = T
)
```

<!-- TODO: nombrar los stacks por parameter modificado -->

#### Recreate arguments

Arguments for cellid must be recreated to use the updated parameters instead.

```{r}
parameters.txt <- rcell2.cellid::parameters_write(parameters.list)

cellid.args <- rcell2.cellid::arguments(data.dir,
                                        file.pattern = arguments.file.pattern,
                                        parameters = parameters.txt)  # Parameters are specified here.

cellid.args
```

### Run Cell-ID

The `cell2` function generates system commands to run Cell-ID,
and executes them in parallel by default.

The `cell.command` argument must be the path to the Cell-ID binary executable.
In this version of `rcell2`, it defaults to `NULL`, and the intenal executable 
is used.

Warning: existing output files **will be overwritten** without warning. 
To check if this will happen before running `cell2`, run "`arguments_check(cellid.args)`"
on the output directory, and check for warnings.

```{r eval=F}
cell2.result <- rcell2.cellid::cell2(arguments = cellid.args, 
                                     output_coords_to_tsv = T)
```

> Run `?cell2` to learn about advanced segmentation parameters, and to generate additional
output files with segmentation masks or identified cell-boundary pixel coordinates.

> `n_cores` can be set to the number of CPU cores you want to use to parallelize
> the segmentation (relying on `foreach`). It defaults to use all but one of the
> available cores.


#### Review segmentation in ImageJ

This section helps you open your images with FIJI-ImageJ to review the resulting segmentation.

A simple Macro can be run in ImageJ to load virtual hyperstacks of any experiment.

> Note: this macro uses a "file" pattern that only matches output images (i.e. "tif.out.tif")
> in a tipically-named set of images.

Steps:

1. Run the following code, copy its output to the clipboard.
2. Open ImageJ/FIJI, and open a new "Macro" window by clicking on "Plugins -> New -> Macro".
3. Paste the macro into the macro editor, and click on "Run". A new hyperstack window will open.
4. Browse the images using the sliders.

```{r}
ijm_open_segmentation(cellid.args)
```

> Note: the dimensions names may be mismatched between R and the macro. This is because 
virtual stacks must be in `xyczt` order (time is likely to end up as the "channels" dimension), 
but the order in which the "Image Sequence..." is loaded depends on how their files are named.

The only restriction of this approach is that only "3" dimensions are available for
browsing: `frame`, `plane`, and `channel`. This is relevant if you wish to browse
segmentation results (which adds another dimension to the set: original vs "out").
A fourth dimension would be needed, but Hyperstacks only provide 3. Alternatively, 
open another virtual hyperstack for the output images, and browse them in-sync.


### Output data

Cell-ID's output consists mainly of:

* Segmented images (named with the `.out.tif` suffix).
  * *Optional:* "BF.out" with identified binary masks.
* Tables with single-cell quantitative information (from their morphology and fluorescence).
  * *Optional:* Tables with the boundary and interior pixels of identified cell.

#### Output file pattern

File patterns for the image set may vary slightly; depending on what images were 
provided as input, and the identifiers in their file names.

The pattern must match file names of fluorescent images, and have a capturing group
for the channel identifier (e.g. `YFP`, `GFP`, etc.).

The most common fluorescent channel patterns for `get_cell_data` and `parameter_scan`
are defined below.

Choose one pattern and comment the others:

```{r}
# Default value: all fluorescent tags, including Z-stack fluorescence channels.
fluorescence.pattern <- "^([GCYRT]FP|[GCYRT]\\d+)_Position\\d+_time\\d+.tif$"

# Default: add "BF" as a possible channel (when CellID was run with bf_as_fl=TRUE)
# fluorescence.pattern <- "^([GCYRT]FP|[GCYRT]\\d+|BF)_Position\\d+_time\\d+.tif$"

# Same as defualt, but without t.frame information.
# fluorescence.pattern <- "^([GCYRT]FP|[GCYRT]\\d+)_Position\\d+.tif$"
```

List files that match the pattern, to check that it works as expected:

```{r}
data.dir %>% 
  dir(pattern = fluorescence.pattern)
```

#### Load the output

The output tables can be loaded with `get_cell_data`.

```{r eval=F}
# Load output
cell.data <- rcell2.cellid::get_cell_data(path = data.dir,
                                          fluorescence.pattern=fluorescence.pattern)
```

> Note: your `fluorescence.pattern` regex may vary (read the [Output file pattern] section above).

Alternatively, function `load_cell_data` from `rcell2` can load those tables as well.

```{r eval=F}
# Install rcell2's main analysis package if unavailable.
if(!requireNamespace("rcell2")){
   devtools::install_github("darksideoftheshmoo/rcell2")
}

# Load output
cell_data <- rcell2::load_cell_data(path = data.dir)
```

Both `rcell2.cellid` and `rcell2` provide the `cell.load.boundaries` function, which can 
load the cell boundaries and interior pixels coordinates.

This data is only available if either `output_coords_to_tsv` or `encode_cellID_in_pixels` 
were set to `TRUE` when Cell-ID was run.

To load the boundary pixels, use the `cell.load.boundaries` function. It can load this 
information from two kinds of sources:

* "`masks.tsv`": from TSV files, available if Cell-ID was run with `output_coords_to_tsv=TRUE`.
* "`out.tif`": from binary masks in TIFF files, available if Cell-ID was run with `encode_cellID_in_pixels=TRUE`.

```{r eval=F}
# Useful if either "output_coords_to_tsv" or "encode_cellID_in_pixels" were TRUE in cell().
cell.boundaries <- 
  rcell2.cellid::cell.load.boundaries(
    data = cellid.args,
    data.source = "masks.tsv",
    pixel.type = "b"
  )
```

#### Variable descriptions

To help understand CellID's output, we documented the descriptions of variables
in `cell.data$data`.

They are available through a function:

```{r}
rcell2.cellid::cellid_output_descriptions(list.output = F)
```

## Data analysis

Helping with data analysis is `rcell2`'s purpose.

Installation instructions for `rcell2` and `rcell2.magick` packages can be found [here](https://github.com/darksideoftheshmoo/rcell2#installing-the-package) and [here](https://github.com/darksideoftheshmoo/rcell2-magick#installing-the-package),
respectively.
