---
title: "rcell2.cellid: Cell-ID Workflow Template"
author: "Nicolás Méndez"
output:
  html_document:
    df_print: paged
    toc: yes
    toc_float:
      collapsed: false
    toc_depth: 4
    number_sections: false
    smooth_scroll: false
    code_folding: show  # hide
    code_download: true
    highlight: breezedark # pygments # tango
    theme: "darkly"
  pdf_document:
    latex_engine: xelatex
    toc: true
    toc_depth: 4
    number_sections: true
editor_options:
  chunk_output_type: inline
date: "`r format(Sys.time(), '%d %B, %Y')`"
urlcolor: blue
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "output/renders") })
# bibliography: references.bib
---

<!-- Download a copy of this file with rcell2.cellid::get_workflow_template_cellid() -->

# Installation

The `rcell2-cellid` package can be installed directly from [its git repository](https://github.com/darksideoftheshmoo/rcell2-cellid) by running the following:

```{r, eval=F}
# The remotes package is required to install R packages from git.
if (!requireNamespace("remotes", quietly = TRUE))
  install.packages("remotes")

# Our lab's GitHub organizacion lives at https://github.com/darksideoftheshmoo/
if (!requireNamespace("rcell2.cellid", quietly = TRUE))
  remotes::install_github("darksideoftheshmoo/rcell2-cellid")
```

# Notebook Setup

```{r setup, include=FALSE}
# Set chunk options
knitr::opts_chunk$set(echo = T, message = F, out.width = "100%", eval = F,
                      # https://stackoverflow.com/a/15081230
                      comment=NA)
                      # https://yihui.org/knitr/options/#chunk-options
                      # https://stackoverflow.com/a/66753995
                      # tidy.opts = list(width.cutoff = 60), tidy = TRUE)
# Remove comments from printed text (https://stackoverflow.com/a/44729363)
# knitr::opts_chunk$set(tidy = TRUE, 
#                       tidy.opts = list(comment = FALSE))


# Set knit options
knitr::opts_knit$set(root.dir = here::here())

library(rcell2.cellid)    # Run CellID entirely in R.
# library(rcell2)         # Load Cell-ID's output
# library(rcell2.magick)  # Filter data using Shiny and preview images with Magick.

library(tidyverse)  # import numpy as np (?)
# library(magick)  # if you need it
```

# Introduction

This notebook contains a [Usage guide] with in-depth explanations and advanced usage examples.

There is another "quick start" notebook bundled with the package.

## Friendly reminder

- **Read this notebook carefully**.
- Use the **help page** of functions before using them. Open help pages with R's `?` (e.g. `?arguments`).
- Read the README.md at rcell2's [GitHub repo](https://github.com/darksideoftheshmoo/rcell2/).

# Usage guide

This section has detailed explanations and usage examples of the tools in `rcell2.cellid`.

## Path to the dataset

First point R to the folder containing the images. This notebook obeys the path
specified in the `data.dir` variable. Make sure to assign its value once, or 
double-check before overwriting it.

### Use yours

If you already have an appropriate dataset, specify the path to the images like this:

> Note: the aprropriate pattern for file names is described at the [Image file names]
> section of this notebook.

```{r, eval=F}
# Location of your image set
data.dir <- "/path/to/your/data"

# R has an interactive file chooser
data.dir <- dirname(file.choose())
```

### Use the examples

Otherwise, install and use the "examples" package, which provides example images and scripts.

First, get the example data:

```{r}
if(!requireNamespace("remotes")){
  # Install the "remotes" package if not found:
  install.packages("remotes")
}

if(!requireNamespace("rcell2.examples", quietly = T)){
  # Install the "rcell2.examples" package if not found:
  remotes::install_github("darksideoftheshmoo/rcell2.examples")
}

# List available datasets:
dir(system.file("extdata/sample_datasets/", package = "rcell2.examples"))
```

Second, get the path to the chosen example dataset and check if the files are there:

> The dataset selected in the chunk below is a subset of a larger experiment.
> The subset contains two positions (4, 12), three time frames (10, 20, 30),
> three 'fluorescence' channels (TFP, YFP), and the mandatory BF channel.

```{r}
# Example: Choose one set of example images:
data.dir <- system.file("extdata/sample_datasets/sample_time_series/",
                        package = "rcell2.examples")
```

> In the chunk above we set up `data.dir` to hold the path to samples images of a
time-course experiment. This will replace any previous value!

Finally, check if the files are there:

```{r}
# List image files in the set:
dir(data.dir) |> head()
```

## Image file names

Images are assumed to be in a single directory, and have names with identifiers for:

* Imaging channel (bright field, transmission, fluorescence, z-slice, etc.).
* Microscope position (*pos*).
* Time (*t.frame*, optional).

Cell-ID uses the first 3 letters of the file name to group imaging channels.
**This is mandatory**. If your image set does not conform initially, it can be
renamed (or symlinked) using rcell2's `rename_mda`, with custom arguments.

For example, file names for a 2-position time course experiment
are expected to have the following appearance:

```
BF_Position001_time01.tif
BF_Position001_time02.tif
TFP_Position001_time01.tif
TFP_Position001_time02.tif
YFP_Position001_time01.tif
YFP_Position001_time02.tif
BF_Position002_time01.tif
BF_Position002_time02.tif
TFP_Position002_time01.tif
TFP_Position002_time02.tif
YFP_Position002_time01.tif
YFP_Position002_time02.tif
```

The `rcell2` packages rely on regular expressions to gather images and extract 
metadata from their file names (i.e. channel, position, and time frame.)

The file list will be recognized by a specific regular expression (regex).
A regex matching these files can be `^(BF|TFP)_Position(\\d+)_time(\\d+).tif$`;
note that it has **3 capturing groups** (suff between parentheses).
The regex as a whole is used to select images from a directory (filtering out
other files) and the capturing groups are used to extract the metadata.

### Renaming images

Metamorph's _Multi-dimensional acquisition_ (MDA for short) may use file 
names different from the usual style (i.e `far6_w2LED-BF--YFPcube--cam_s7_t2.TIF` 
instead of `BF_Position07_time02.tif`, and so on).

The `rename_mda` function renames those files names, making them compatible
with `rcell2`'s defaults. See `?rename_mda` for extra options.

The defaults are useful for a three channel experiment, 
and file names looking like this: `far6_w2LED-BF--YFPcube--cam_s7_t2.TIF`.

#### Rename a single file

A preview of how files will be renamed can be generated:

```{r}
# Choose a sample file name (one or many)
one.filename <- "far6_w2LED-BF--YFPcube--cam_s7_t2.TIF"

# Pass it to rename_mda, setting rename.function to NULL (to avoid actually copying files).
result <- rename_mda(rename.function = NULL, 
                     file.names = one.filename)

# Get the info we're interested in
result$status %>% select(file, rename.file)
```

A "renaming data frame" (`images.info` below) can be extracted and examined before renaming all images:

```{r}
# Set rename.function to NULL (to avoid actually copying files).
images.info <- 
  rename_mda(rename.function = NULL, 
             rename.dataframe = TRUE,
             file.names = one.filename)

images.info
```

The updated `images.info` data frame can also be adjusted and then used to rename images:

```{r}
# Example: adjust "t.frame".
images.info <- images.info |> mutate(t.frame = 99)

# Pass the updated data.frame to the "rename.dataframe" argument.
# Set rename.function to NULL (to avoid actually copying files for now).
images.info.final <- 
  rename_mda(rename.function = NULL, 
             rename.dataframe = images.info,
             file.names = one.filename)

images.info.final
```

A _dummy_ example follows:

```{r}
# Path to the images produced by MetaMorph's MDA.
images.path <- file.path(tempdir(), "images")
# Create a temporary directory
dir.create(images.path)
# Create a dummy file
writeLines(text = "dummy content", 
           con = paste0(images.path, "far6_w2LED-BF--YFPcube--cam_s7_t2.TIF"))

# Rename files
rename_mda(images.path)
```

List all files in the images directory to inspect the result:

```{r}
dir(images.path, recursive = T)
```

#### Rename all files

To run the function on all images, provide the path to the images directory.

```{r}
result <- rename_mda(images.path = data.dir)
```

Update the value of the `data.dir` variable:

```{r}
data.dir <- result[["rename.path"]]
```

The defaults are easily adaptable to other use cases. 
To use the function with different file name patterns, adjust `identifier.pattern`,
`identifier.info`, and `channel.maping.df`. See `?rename_mda` for details.

> Note that the `ch` field in `channel.maping.df` must match exactly the
> text captured by the channel group in the `identifier.pattern` regex.
> Read the function's help page for details: `?rename_mda`.

#### Join multiple MDA runs

In some setups, you might end up with several image sets, from consecutive MDAs.

The full list of images can recovered and renamed to form a single image set for Cell-ID.

The `rename_mdas` is meant for this use case.

```{r}
result <- rename_mdas(images.path = data.dir,
                      # Example pattenrs:
                      identifier.pattern=".*_w(\\d).*_s(\\d{1,2})_t(\\d{1,2}).TIF$",
                      identifier.info = c("ch", Position="pos", time="t.frame"),
                      channel.maping.df = data.frame(ch = 1:4, ch.name = c("TFP", "BF", "RFP", "YFP")))

result
```

The renamed images arecan be found in the following path:

```{r}
result[["rename.path"]]
```

## Preprocessing

The following sections may help improve the result of the segmentation,
to catch severe issues early on.

### Check that your images are there

The `arguments` function will run several tests (using `arguments_check` internally)
before returning the list of images for Cell-ID. Warnings (or errors if desired) will 
be raised if the checks fail.

You can also set `check_fail = FALSE` to inspect all warnings without raising an error.

> **Note**: the usage of the "file.pattern" argument is explained at the
> [Arguments] section of this notebook.

```{r}
# Get images and their metadata.
image_list <- rcell2.cellid::arguments(data.dir, 
                                       check_fail = TRUE,
                                       file.pattern = "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$")
```

If images are missing, the command above will fail.

Missing images in the set can be located visually by plotting with `geom_tile`.

In this case, it is important to set `bf_as_fl = T` and `check_fail = F` in order
to get the complete image list (i.e. including `BF` as a channel), and skip errors
if images are missing (and thus the image list may be malformed).

An example follows:

```{r}
i <- rcell2.cellid::arguments(path = data.dir, 
                              bf_as_fl = T,
                              check_fail = F,
                              file.pattern = "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$")

d <- i |> 
  group_by(pos, ch, t.frame) |> 
  summarise(n=n()) |> 
  ungroup() |> 
  complete(pos, ch, t.frame)

p <- d |> ggplot() +
  geom_tile(aes(t.frame, pos, fill=!is.na(n))) +
  facet_wrap(~ch) + 
  theme_minimal()

p  # plotly::ggplotly(p)
```

You can also inspect the table manually:

```{r}
View(image_list)
```

### Check XY stage coordinates

It may be a good idea to double check that the physical coordinates of your images
match your expectations (i.e. the column/row pairs of each well in a microscopy plate).
This information is stored in TIFF's metadata.

It requires the `ijtiff` and `XML` packages, install them by running the following:

```{r}
if(!requireNamespace("ijtiff")) install.packages("ijtiff")
if(!requireNamespace("XML")) install.packages("XML")
```

<!-- Internal note: The xml2 package does not convert the attributes automatically, 
so I stuck to the XML package. See tiff_plane_info's help and source for details. -->

#### Plot position overlaps

The following code match the images' _position_ (Pos) to their microscope stage _physical_ XY coordinates,
which are stored in the TIFF tags of the original images.

This plot is specially useful when tracing a path for positions in a multi-well time-course experiment.

It requires the `images` dataframe in `cell.data` to get the file names,
_but_ you could also use `dir` to get the files by pattern, and `sub` to get the position IDs,
independently of Cell-ID.

Optionally set details from your microscope (e.g. magnification and physical size of the camera's pixels).

```{r}
# Get images.
image_list <- rcell2.cellid::arguments(path = data.dir,
                                       file.pattern = "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$")

# Extract metadata and plot stage positions.
result <- plot_pos_overlaps(image_list, channels = "TFP")

# The plot can be found in the output list.
# result$plt
```

> If any two shaded areas overlap, there will be duplicated cells in the dataset.

We do not yet offer a way to remove them automatically. You may do this yourself
by finding the XY coordinates of the first cells not shared between images, and using
their coordinates to remove the overlapping set from one position.

### Preview images using ImageJ

No analysis package exists (yet) that can replace a researcher's general visual assessment.

This section helps you open your images with FIJI-ImageJ before you begin.

A simple Macro can be run in ImageJ to load virtual hyperstacks of any experiment.

> Note: this macro uses a "file" pattern that only matches input images (and not ".out")
> in a tipically-named set of images.

Steps:

1. Run the following code, copy its output to the clipboard.
2. Open ImageJ/FIJI, and open a new "Macro" window by clicking on "Plugins -> New -> Macro".
3. Paste the macro into the macro editor, and click on "Run". A new hyperstack window will open.
4. Browse the images using the sliders.

```{r}
# Get images and their metadata.
image_list <- rcell2.cellid::arguments(data.dir,
                                       file.pattern = "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$")

# Convert the "arguments" to a list of "images" required to make the ImageJ macro.
image_list |> 
  arguments_to_images() |>
  ijm_open_hyperstack(use_out = F)
```

> Note: the dimensions names may be mismatched between R and the macro if `fix_order=F`. 
> This is because virtual stacks must be in `xyczt` order (time is likely to end up as the "channels" dimension),
> but the order in which the "Image Sequence..." is loaded depends on how their files are named.

The only restriction of this approach is that only "3" dimensions are available for
browsing: `frame`, `plane`, and `channel`. This is relevant if you wish to browse
segmentation results (which adds another dimension to the set: "original" vs "out").
A fourth dimension would be needed, but Hyperstacks only provide 3. The default is to
load "out" files as new channels.

### Check acquisition times

Acquisition times can be extracted from metadata in the TIFF files produced by MetaMorph.

```{r}
# Get images.
image_list <- rcell2.cellid::arguments(path = data.dir,
                                       file.pattern = "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$") |> 
  suppressWarnings()
```

Extract time information for the BF channel only:

```{r}
time_info <- get_time_info(image_list = image_list, channels = "BF")
```

> Note that ImageJ's FFT filter will not add MetaMorph's metadata to the filtered BFs.
> This means that `get_time_info` will only work on the original TIFF files.

Distribution of time intervals:

```{r}
time_info |> filter(pos == first(pos)) |> 
  with(acquisition.time.ct) |>as.numeric() |> diff() |> 
  hist(main="Distribution of time interval between frames", 
       xlab="Interval time (seconds)")
```

`t.frame` plotted against the acquisition time difference should be completely flat,
if acquisition intervals were perfectly even.

```{r}
time_info |> 
  # Compute acq. time differences by position.
  group_by(pos) |> arrange(t.frame) |>
  mutate(acq_delta=c(NA, diff(acquisition.time.ct)))  |> 
  # Plot.
  ggplot(aes(t.frame, acq_delta, color=as.factor(pos), group=pos)) +
  geom_line() + 
  ylim(c(0, NA)) + ylab("Minutes since last frame") + #guides(color=F) +
  ggtitle("Elapsed time between frames")
```

This plot will show the actual local time for each image frame, and should be diagonal:

```{r}
time_info |> 
  ggplot(aes(acquisition.time.ct, t.frame)) +
  geom_line() + 
  facet_wrap(~pos) +
  ggtitle("Acquisition time vs Image frame index")
```

### Apply FFT filter on BF images

Optionally, use ImageJ's band-pass FFT filter on the defocused bright field images.

This can help Cell-ID find cells and reduce background artifacts.

List the BF images from the `arguments` function:

```{r eval=F}
# Get image paths
cellid.args <-
  rcell2.cellid::arguments(path = data.dir,
                           file.pattern = "^(BF|[TRY]FP)_Position(\\d+)_time(\\d+).tif$")
```

The `run_fft_filter_on_bfs` will launch ImageJ in the background and apply the FFT filter on a copy of the images.

In brief, it will:

- Split the BF files by position, and symlink them to different subdirectories.
- Run FFT filter in parallel using a macro, with one ImageJ instance per subdirectory.
- Symlink filtered BFs from each subdirectory to a single "filtered" images directory.
- Symlink the rest of the images (i.e. fluorescence images) to the "filtered" directory.

Run the filter:

```{r eval=F}
new.data.dir <- run_fft_filter_on_bfs(
  data.dir = data.dir,
  cellid.args = cellid.args,
  # imagej.path="~/Software/ImageJ/Fiji.app/ImageJ-linux64") # Adjust to your system
  imagej.path="~/Software/ImageJ-FIJI/Fiji.app/ImageJ-linux64") # Adjust to your system

new.data.dir
```

You can run Cell-ID using the new directory as the new `data.dir`:

```{r eval=F}
data.dir <- normalizePath(new.data.dir)
```

## Segmentation

In this section we will prepare arguments for Cell-ID and segment cells in images.

### Parameters

First we must configure the Cell-ID parameters that affect cell segmentation, 
tracking, and some corrections.

#### Descriptions

Show a data.frame with the description of each Cell-ID parameter:

```{r}
parameters_help_df
```

Also available in list format:

```{r}
parameters_help$max_dist_over_waist
```

#### Values

Here is a valid, _hand-made_ parameter list, with the defaults I like:

```{r eval=F}
parameters.list <- list(
  max_split_over_minor = 0.50,
  max_dist_over_waist = 8.00,
  max_pixels_per_cell = 2000,
  min_pixels_per_cell = 75,
  background_reject_factor = 0.75,
  tracking_comparison = 0.20,
  align_individual_cells = F,
  align_fl_to_bf = T,
  image_type = "brightfield",
  bf_fl_mapping = "list"
  )
```

Fortunately you don't have to do this by hand. `parameters_default` is a helper 
function to prepare the parameters list more easily, and also documents them 
(run `?parameters_default` to learn more).

Lets use the `parameters_default` function to generate all the required 
parameters, overriding only the value of the `background_reject_factor` parameter:

```{r}
parameters.list <- 
  rcell2.cellid::parameters_default(
    background_reject_factor = 0.4
  )

parameters.list$background_reject_factor
parameters.list$max_split_over_minor
```

#### The file

> *Note*: This section is no longer critical. The `arguments` function also 
> accepts a list of parameters, or a > `data.frame` with position numbers and 
> paths to parameter files. See `?arguments` for details

This parameter list must be written to a `parameters.txt` plain text file with 
the proper syntax, which Cell-ID will read later on.

For this purpose, you may use the `parameters_write` function. As its name 
implies, it writes the parameters, and returns the path where it was saved.

<!-- Internal note: consider moving this step into cell2() -->

```{r}
parameters.txt <- rcell2.cellid::parameters_write(parameters.list)

parameters.txt
```

This path can be passed to the `arguments()` function in the next section.

Lets read the contents of the `parameters.txt` file we just saved.

```{r}
# Mostrar el contenido del archivo
writeLines(readLines(parameters.txt))
```

### Arguments

The `arguments` function outputs a `data.frame` with information from images and
segmentation parameters, which is needed to run Cell-ID.

The key parameter is `file.pattern`, a regular expression used to find image
files in the `data.dir` folder.

The path to the images of your experiment must be already defined,
as explained in the [Path to the dataset] section of this notebook.

#### Image file pattern

By default, `arguments` uses the following pattern:

    "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$"

Note that enclosed in parentheses are the "capture groups" of the regular expression.
These delimit the parts of the file name which contain identifiers for:

1. Imaging channel (`ch`).
2. Stage position index (`pos`).
3. Time-frame index (`t.frame`).

If your experiment has a single time frame, and it is not part of the file names,
the content of the corresponding capturing group can be deleted (leaving the
empty parenthesis in place):

    "^(BF|[A-Z]FP)_Position(\\d+)().tif$"

The regular expression can be used to select or filter out sets of images (
though it will be often easier to use R's tool for this). To select only position
with index "2", and times 2, 3 and 4, use:

    "^(BF|[A-Z]FP)_Position(0*2)_time(0*[423]).tif$"

> Note the `0*` in front of numbers. This indicates that there might me be leading
> zeros in front of the position and time identifiers.

If the identifiers on your file names appear in a different order, either rename them as
shown in the [Renaming images] section, or reorder the default `file.pattern.groups.order`
in the call to `arguments`.

Note, however, that the channel identifier _must_ be first. Cell-ID will use the
**first three letters** to distinguish and group imaging channels.

> **Important**: the patterns used in `arguments` must match the ones used in
> `get_cell_data` when loading Cell-ID's output (later on).

Images file pattern examples; choose one and comment the others:

```{r}
# Default value: all channels, no z-stack.
arguments.file.pattern <- "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$"

# To consider z-stacks:
# arguments.file.pattern <- "^(BF|[A-Z]\d+)_Position(\d+)_time(\d+).tif$"

# BF or TFP only, no t.frame info.
# arguments.file.pattern <- "^(BF|TFP)_Position(\\d+)().tif$"
```

Learn more by opening the help page of the `rcell2.cellid::arguments` function.

#### Usage

Now, load image file names from a `data.dir` directory, with names matching the
`arguments.file.pattern` regular expression, and set segmentation `parameters`:

```{r}
cellid.args <- rcell2.cellid::arguments(
  # Path to the images.
  path = data.dir,
  # File pattern to recognize the images.
  file.pattern = arguments.file.pattern,
  # Parameters are specified here.
  parameters = parameters.list
)

cellid.args
```

You can filter out or select certain image sets at this stage:

```{r}
cellid.args %>% filter(pos == 2, t.frame %in% c(4,2,3))
```

#### Nuclear or Vacuolar tags

Images containing the location of the nucleus or vacuole can be used
to derive extra measurements from those structures.

A "third" image list must be added to the arguments. In the following example,
the YPF channel is added to the arguments to a new column named "`third`" exactly.

```{r}
# Optionally Add "third" column
cellid.args <-  left_join(
  cellid.args,
  cellid.args %>% filter(ch == "YFP") %>% select(pos, t.frame, image) %>% rename(third = image)
)
```

The `cell2` function will look for this column and pass the images to Cell-ID if found.

To enable this feature in Cell-ID, the parameters must have been 
also configured (see `?parameters_default`) by setting `third_image` to
"vacuole_label" or "nuclear_label".

### Tuning parameters

Sometimes we want to test out many parameter combinations 
before running Cell-ID in the full dataset.

> If you use Cell-ID often, your cells' morphologies do not change dramatically,
> and you are using the same microscope as the last time, you may be better off 
> reusing those parameters and skipping this section.

This functionality requires the `magick` R package,
and ImageMagick on your system (which can be obtained 
[here](https://imagemagick.org/script/download.php)). 

Run the following to install the R package if absent:

```{r}
if(!requireNamespace("magick")){
  install.packages("magick")
}
```

#### Setup

Prepare the patterns and arguments as usual (if not done already):

```{r}
# Default value: all channels, no z-stack.
arguments.file.pattern <- "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$"

# Get full image list
cellid.args <- rcell2.cellid::arguments(path = data.dir,
                                        file.pattern = arguments.file.pattern)
```

##### Image set

Choose which of the image sets in `cellid.args` you wish to use for the parameter scan.

For example, choose some *positions* (image sets) and *t.frame*s (time frames)
to restrict the image test set to only some of them.

Some guidelines:

1. Choose at least one image and frame from a "control" situation.
2. Choose at least one image and frame from a "treated" situation, where cells might vary in morphology.
  - A much later time, with larger cells.
  - Treated cells, which might show shmoos.
3. Choose more than one consecutive frame to asses the stability of your segmentation parameters over adjacent frames.

```{r}
# Choose test positions, frames and channels.
test.pos = unique(cellid.args$pos)[1]        # e.g.: One position.
test.frames = unique(cellid.args$t.frame)[1] # e.g.: One frame.
test.chs = unique(cellid.args$ch)[1]         # e.g.: One channel.

# Filter cellid.args to choose image sets for the scan
scan.arguments <-  
  subset(cellid.args, 
         pos %in% test.pos & t.frame %in% test.frames & ch %in% test.chs)

# Examine the subset
scan.arguments
```

##### Parameter sets

For each parameter variation, we need a new parameters file. The simplest way to
generate parameter combinations is with rcell2's `parameters_default` and R's `expand.grid`.

Because scanning over all parameters space would take ages, you can follow a 
simplified procedure of 3 small scans, on a small subset of images. 

Here is a procedure to reduce the scan's complexity:

0. Relax segmentation parameters:
  - Set `max_split_over_minor` and `max_pixels_per_cell` to high values (e.g. `5` and `5000`).
  - Set `min_pixels_per_cell` to a low value (e.g. `30`).
1. First scan over `background_reject_factor` *only* (e.g. between `0` and `2`).
  - Set `background_reject_factor` to its optimal value, which maximizes 
    detection of cells, and minimizes segmentation artifacts.
3. Scan over `max_dist_over_waist`.
4. Fix `max_dist_over_waist` to its optimal value, which adjacent cells and 
   daughters cells from their mothers.
  - At this point you must tolerate projected growth (i.e. shmoos) being split 
    from the rest of the cell body.
5. Scan over `max_split_over_minor` *only*, which should minimize the amount of 
   growth projections split from their bodies.

> Do not skip the first step, is will make the interpretation of parameters simpler.
> For example, `max_dist_over_waist` can split "figure-8" cells into two,
> and `max_split_over_minor` will re-join shmoo-like cells that were split,
> possibly masking the effect of the first.
> Furthermore, "split" small cells and "joined" large cells can be removedby the
> pixel limits. 

In the following example, only `background_reject_factor` is scanned, across 
values produced with R's `seq` function:

```{r}
parameters.list <- rcell2.cellid::parameters_default(
  background_reject_factor = seq(from=0, to=1.5, by = 0.4)
)

parameters.list$background_reject_factor
```

The parameters list must now be expanded into a data.frame, 
with a row for every possible combination of parameter values:

```{r}
parameters.df <- expand.grid(parameters.list)

parameters.df
```

> Note: You might want to select some rows from that table. In that case, simply filter it.

##### Test directory

Define working paths for parameter scanning:

* `data.dir`: directory with the original images (they will not be modified).
* `test.dir`: directory for temporary files of the tuning process.

```{r}
# Set your own path, or uncomment the following to use example images.
# data.dir <- system.file("extdata/sample_datasets/sample_time_series/",
#                         package = "rcell2.examples")

# The output of the parameter scan will be saved here:
test.dir <- file.path(tempdir(), "images_directory", "test.dir")
test.dir
```

#### Run the Scan

> Now comes the magic part.

The `parameter_scan` function uses temporary directories to work on images, 
and avoids messing up the main data directory, 
while running Cell-ID in parallel for each parameter variation.

Just run:

```{r eval=F}
scan.results <- 
  parameter_scan(parameters.df = parameters.df,
                 # Optionally choose the temporary output directory by setting "test.dir".
                 scan.arguments = scan.arguments)
```

> Have a look at the function's source code if you like, its hopefully well commented.

#### Review result in ImageJ

Prepare virtual TIFF stacks for a one or more imaging channels, with the `make_scan_stacks` function.

To help the user choose a parameter set, the stacks are annotated with the parameters used
for the segmentation, and other metadata (position, time frame, and channel).

There are two alternatives: `annotate_scan_output` and `make_scan_stacks`. The first will
annotate the images and save them, and the latter will annotate the images and save them
to a stack. Note that making a stack can consume all your system's RAM if the scan is 
moderately large. We recommend using `annotate_scan_output`.

A copy-paste-ready ImageJ Macro will be printed out by either function, 
to easily load the stacks as virtual Hyperstacks in ImageJ.

**Option A**: `annotate_scan_output`

This function will annotate individual images, save them, and compose an ImageJ
macro, to inspect them in a single _virtual_ stack.

The macros are printed to the console, and are also available in the output 
of `annotate_scan_output`.

> **Tip**: copy-paste the macro to a new macro window in ImageJ, and hit run!
> The stack should be loaded auto-magically.

```{r}
imagej_macros <- annotate_scan_output(scan.results = scan.results, 
                                      in.place = FALSE,
                                      preserve_source_imgs = TRUE,
                                      annotated.imgs.dir = "annotated",
                                      annotation.font = "Hack")
```

**Option B**: `make_scan_stacks`

This function will make TIFF stacks, which can take a long time if the image
set is large, but are easier to open (i.e. without a macro).

```{r eval=F}
stack.paths <- 
  make_scan_stacks(scan.results = scan.results, 
                   stack.channels = "BF.out")
```

Paths and macros are available in the output of `make_scan_stacks`:

```{r}
names(stack.paths)
```

```{r}
stack.paths$stack.paths
```

```{r}
stack.paths$imagej.macros
```

#### Useful Plots

A few quantities are calculated for each run of the scan, which can be 
indicative of segmentation quality, and may be useful for selecting parameters 
programatically (i.e. without visual inspection with ImageJ/FIJI).

* Cell-ID variables:
  * `fft`
  * `el.p`
  * and so on...
* Derived measures:
  * `ucids`: Total amount of distinct `ucid`s. Increases with segmentation artifacts and unstable tracking.
  * `persistence`: Average number of time frames per cell. Correlates with stable segmentation and tracking.
  * `roughness` & `roughness2`: Indicative of the average "roughness" in the evolution of `a.tot` across time frames.

<!-- Internal note: TO-DO: add explanations of these quantitites. -->

The average of these quantities may be useful for selecting optimal parameters.
A few of combinations these are plotted below.

First get the output data frame from the scan results:

```{r}
results.bound <- scan.results$results.bound
```

You can then start making a few plots.

```{r}
# Avg. frames per cell (persistence) VS 'el.p/fft' per parameter variation
results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(persistence, el.p/fft, label = id,
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. frames per cell (persistence) VS 'el.p/fft' per parameter variation") +
  theme_minimal() + scale_color_discrete()

# Avg. frames per cell (persistence) VS 'el.p/fft' per parameter variation
results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(persistence, el.p/fft, label = id,
                 color = as.ordered(max_split_over_minor)),
             alpha = .7, fill = "NA") +
  ggtitle("Avg. frames per cell (persistence) VS 'el.p/fft' per parameter variation") +
  theme_minimal() + scale_color_discrete()
```

And more plots:

```{r}
# Avg. el.p VS Avg. fft.stat per parameter variation
results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(el.p, fft, label = id,
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. el.p VS Avg. fft.stat per parameter variation") +
  theme_minimal() + scale_color_discrete()

# Avg. roughness per cell VS Avg. frames per cell (persistence) per parameter variation
results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(roughness, persistence, label = paste0(id, "=", background_reject_factor),
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. roughness per cell VS Avg. frames per cell (persistence) per parameter variation") +
  theme_minimal() + scale_color_discrete()

# Avg. roughness2 per cell VS Avg. frames per cell (persistence) per parameter variation
results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(roughness2, persistence, label = paste0(id, "=", background_reject_factor),
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. roughness2 per cell VS Avg. frames per cell (persistence) per parameter variation") +
  theme_minimal() + scale_color_discrete()
```

#### Final parameter set

This parameter set was chosen for FFT-filtered BFs.

Under 0.8 background_reject_factor, there were some "persistent" _ghosts_;
elongated _chorizos_ on the sides of cells.

```{r eval=F}
parameters.list <- rcell2.cellid::parameters_default(
  background_reject_factor = 0.8,
  max_split_over_minor = 0.6,
  max_dist_over_waist = 6,
  max_pixels_per_cell = 3500,
  treat_brightfield_as_fluorescence_also = T
)
```

#### Recreate arguments

Arguments for Cell-ID must be recreated to use the updated parameters instead.

```{r}
parameters.txt <- rcell2.cellid::parameters_write(parameters.list)

cellid.args <- rcell2.cellid::arguments(data.dir,
                                        file.pattern = arguments.file.pattern,
                                        parameters = parameters.txt)  # Parameters are specified here.

cellid.args
```

### Run Cell-ID

The `cell2` function generates system commands to run Cell-ID,
and executes them in parallel by default.

> *Tip*:
> `n_cores` can be set to the number of CPU cores you want to use to parallelize
> the segmentation (relying on `foreach`). It defaults to use all but one of the
> available cores.

> **Warning**: existing output files **will be overwritten** without warning. 
> To check if this will happen before running `cell2`, run `arguments_check(cellid.args)`.
> It will check if any output files exist and print messages to the console.

```{r eval=F}
cell2.result <- rcell2.cellid::cell2(arguments = cellid.args, 
                                     output_coords_to_tsv = T)
```

The `cell.command` argument must be the path to the Cell-ID binary executable.
In this version of `rcell2`, it defaults to `NULL`, and the bundled executable 
is used.

> *Tip*:
> Run `?cell2` to read about advanced segmentation parameters, You can, for example,
> set flags to generate additional output files with segmentation masks or 
> identified cell-boundary pixel coordinates.

#### Review segmentation in ImageJ

This section helps you open your images with FIJI-ImageJ to review the resulting segmentation.

A simple Macro can be run in ImageJ to load virtual hyperstacks of any experiment.

> *Note*: this macro uses a "file" pattern that only matches output images (i.e. "tif.out.tif")
> in a tipically-named set of images.

Steps:

1. Run the following code, copy its output to the clipboard.
2. Open ImageJ/FIJI, and open a new "Macro" window by clicking on "Plugins -> New -> Macro".
3. Paste the macro into the macro editor, and click on "Run". A new hyperstack window will open.
4. Browse the images using the sliders.

```{r}
ijm_open_segmentation(cellid.args)
```

> *Note*: the dimensions names may be mismatched between R and the macro. This is because 
virtual stacks must be in `xyczt` order (time is likely to end up as the "channels" dimension), 
but the order in which the "Image Sequence..." is loaded depends on how their files are named.

The only restriction of this approach is that only "3" dimensions are available for
browsing: `frame`, `plane`, and `channel`. This is relevant if you wish to browse
segmentation results (which adds another dimension to the set: original vs "out").
A fourth dimension would be needed, but Hyperstacks only provide 3. Alternatively, 
open another virtual hyperstack for the output images, and browse them in-sync.


### Output data

Cell-ID's output consists mainly of:

* Segmented images (named with the `.out.tif` suffix).
  * *Optional:* "BF.out" with identified binary masks.
* Tables with single-cell quantitative information (from their morphology and fluorescence).
  * *Optional:* Tables with the boundary and interior pixels of identified cell.

#### Output file pattern

File patterns for the image set may vary slightly; depending on what images were 
provided as input, and the identifiers in their file names.

The pattern must match file names of fluorescent images, and have a capturing group
for the channel identifier (e.g. `YFP`, `GFP`, etc.).

The most common fluorescent channel patterns for `get_cell_data` and `parameter_scan`
are defined below.

Choose one pattern and comment the others:

```{r}
# Default value: all fluorescent tags, including Z-stack fluorescence channels.
fluorescence.pattern <- "^([GCYRT]FP|[GCYRT]\\d+)_Position\\d+_time\\d+.tif$"

# Default: add "BF" as a possible channel (when CellID was run with bf_as_fl=TRUE)
# fluorescence.pattern <- "^([GCYRT]FP|[GCYRT]\\d+|BF)_Position\\d+_time\\d+.tif$"

# Same as defualt, but without t.frame information.
# fluorescence.pattern <- "^([GCYRT]FP|[GCYRT]\\d+)_Position\\d+.tif$"
```

List files that match the pattern, to check that it works as expected:

```{r}
data.dir %>% 
  dir(pattern = fluorescence.pattern)
```

#### Load the output

The output tables can be loaded with `get_cell_data`.

```{r eval=F}
# Load output
cell.data <- rcell2.cellid::get_cell_data(path = data.dir,
                                          fluorescence.pattern=fluorescence.pattern)
```

> Note: your `fluorescence.pattern` regex may vary (read the [Output file pattern] section above).

Alternatively, function `load_cell_data` from `rcell2` can load those tables as well.

```{r eval=F}
# Install rcell2's main analysis package if unavailable.
if(!requireNamespace("rcell2")){
   devtools::install_github("darksideoftheshmoo/rcell2")
}

# Load output
cell_data <- rcell2::load_cell_data(path = data.dir)
```

#### Load cell boundaries

Both `rcell2.cellid` and `rcell2` provide the `cell.load.boundaries` function, which can 
load the cell boundaries and interior pixels coordinates.

This data is only available if either `output_coords_to_tsv` or `encode_cellID_in_pixels` 
were set to `TRUE` when Cell-ID was run.

To load the boundary pixels, use the `cell.load.boundaries` function. It can load this 
information from two kinds of sources:

* "`masks.tsv`": from TSV files, available if Cell-ID was run with `output_coords_to_tsv=TRUE`.
* "`out.tif`": from binary masks in TIFF files, available if Cell-ID was run with `encode_cellID_in_pixels=TRUE`.

```{r eval=F}
# Useful if either "output_coords_to_tsv" or "encode_cellID_in_pixels" were TRUE in cell().
cell.boundaries <- 
  rcell2.cellid::cell.load.boundaries(
    data = cellid.args,
    data_source = "masks.tsv",
    pixel.type = "b"
  )
```

#### Variable descriptions

To help understand Cell-ID's output, we documented the descriptions of variables
available in the `cell.data$data` data frame.

They are available in `output_help` and `output_help_df`:

```{r}
rcell2.cellid::output_help_df
```

## Export results to RDS files

The two main objects in `cell.data` are the `data` and `images` data frames, containing
measurements of individual cells and metadata about the image set of the experiment.

These data frames are used in downstream analyses with `rcell2` and `rcell2.magick`, 
and are often referred to as `cdata` and `paths` respectively.

You may optionally export these to individual RDS files.

```{r}
# Save the full cell.data object to an RDS file.
cell.data |> 
  saveRDS("data/cell.data.RDS")

# Save cdata to an RDS file.
cell.data |> with(data) |> 
  saveRDS("data/cdata.RDS")

# Save images to an RDS file.
cell.data |> with(images) |> 
  saveRDS("data/images.RDS")
```

If you export the results to RDS files, you can load them later on using `readRDS`.

## Data analysis

Helping with data analysis is the purpose of the `rcell2` and `rcell2.magick` packages.

Installation instructions for `rcell2` and `rcell2.magick` packages can be found [here](https://github.com/darksideoftheshmoo/rcell2#installing-the-package) and [here](https://github.com/darksideoftheshmoo/rcell2-magick#installing-the-package),
respectively.
