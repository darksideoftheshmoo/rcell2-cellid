---
title: "rcell2.cellid: Cell-ID Workflow Template"
author: "Nicolás Méndez"
output:
  html_document:
    df_print: paged
    toc: yes
    toc_float:
      collapsed: false
    toc_depth: 4
    number_sections: false
    smooth_scroll: false
    code_folding: show  # hide
    code_download: true
    highlight: breezedark # pygments # tango
    theme: "darkly"
  pdf_document:
    latex_engine: xelatex
    toc: true
    toc_depth: 4
    number_sections: true
editor_options:
  chunk_output_type: inline
date: "`r format(Sys.time(), '%d %B, %Y')`"
urlcolor: blue
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "output/renders") })
# bibliography: references.bib
---

<!-- Download a copy of this file with rcell2.cellid::get_workflow_template_cellid() -->

# Installation

The `rcell2-cellid` package can be installed directly from [its git repository](https://github.com/darksideoftheshmoo/rcell2-cellid) by running the following:

```{r, eval=F}
# The remotes package is required to install R packages from git.
if (!requireNamespace("remotes", quietly = TRUE))
  install.packages("remotes")

# Our lab's GitHub organization lives at https://github.com/darksideoftheshmoo/
if (!requireNamespace("rcell2.cellid", quietly = TRUE))
  remotes::install_github("darksideoftheshmoo/rcell2-cellid")
```

To update, run `install_github("darksideoftheshmoo/rcell2-cellid")` again.

# Notebook Setup

```{r setup, include=FALSE}
# Set chunk options
knitr::opts_chunk$set(echo = T, message = F, out.width = "100%", eval = F,
                      # https://stackoverflow.com/a/15081230
                      comment=NA)
                      # https://yihui.org/knitr/options/#chunk-options
                      # https://stackoverflow.com/a/66753995
                      # tidy.opts = list(width.cutoff = 60), tidy = TRUE)
# Remove comments from printed text (https://stackoverflow.com/a/44729363)
# knitr::opts_chunk$set(tidy = TRUE, 
#                       tidy.opts = list(comment = FALSE))


# Set knit options
knitr::opts_knit$set(root.dir = here::here())

library(rcell2.cellid)    # Run CellID entirely in R.
# library(rcell2)         # Load Cell-ID's output
# library(rcell2.magick)  # Filter data using Shiny and preview images with Magick.

library(tidyverse)  # import numpy as np (?)
# library(magick)  # if you need it
```

# Introduction

This notebook contains a [Usage guide] with in-depth explanations and advanced usage examples.

There is another "quick start" notebook bundled with the package.

## Friendly reminder

- **Read this notebook carefully**.
- Use the **help page** of functions before using them. Open help pages with R's `?` (e.g. `?arguments`).
- Read the README.md at rcell2's [GitHub repo](https://github.com/darksideoftheshmoo/rcell2/).

## Prepare position metadata

For many-well experiments in a 384 microscopy plate, you may benefit from generating stage positions for MetaMorph's MDA automatically.

First, open and fill out the template spreadsheet, which must contain sheets with these names:

1. "`pdata`": with the position metadata. This table will be useful in the future too (e.g. for analyzing results).
2. "`well_order`": with a representation of the plate indicating the order in which to take pictures.
3. "`well_images`": with a representation of the plate indicating how many images to acquire in each well.

The template can be copied to the current working directory with the `get_spos_template` function:

```{r}
template_path <- get_spos_template(save_to = "data/stage_positions.xlsx")
```

If you added the position metadata to "grids" in other sheets (instead of the table in the main `pdata` sheet)
you can use them to generate a full `pdata` table with the `make_pdata` function, by setting the `pdata_sheets`
argument to a vector with the names of those sheets.

```{r}
pdata <- make_pdata(template_path)

# Un-comment to extract additional metadata from "grids" in other sheets.
# pdata <- make_pdata(template_path, pdata_sheets = c("strain", "pheromone"))

pdata
```

### Prepare stage metadata

After filling out the template, use `make_stage_list` to generate the `.STG` file,
which can finally be imported in to MetaMorph's MDA.

```{r}
stage_coords <- template_path |> 
  make_stage_list(af_offset_default = 3.5,
                  stg_output_path = "data/stage_list.STG",
                  # Set this to NULL to disable Z-tilt correction.
                  calib_stg_path = TRUE)

stage_coords$positions_plot #|> plotly::ggplotly()
```

If the calibration was already applied, the following plot should show 0 error:

```{r}
stage_coords_adj <- stage_coords |> 
  with(stage_coords) |> 
  adjust_stg_z(plot_error = TRUE)
```

# Usage guide

This section has detailed explanations and usage examples of the tools in `rcell2.cellid`.

## Path to the dataset

First point R to the folder containing the images. This notebook obeys the path
specified in the `data.dir` variable. Make sure to assign its value once, or 
double-check before overwriting it.

### Use yours

If you already have an appropriate dataset, specify the path to the images like this:

> Note: the aprropriate pattern for file names is described at the [Image file names]
> section of this notebook.

```{r, eval=F}
# Location of your image set
data.dir <- "/path/to/your/data"

# R has an interactive file chooser
data.dir <- dirname(file.choose())
```

### Use the examples

Otherwise, install and use the "examples" package, which provides example images and scripts.

First, download the example data:

```{r}
# Install the "remotes" package if not found:
if(!requireNamespace("remotes")){
  install.packages("remotes")
}

# Install the "rcell2.examples" package if not found:
if(!requireNamespace("rcell2.examples", quietly = T)){
  remotes::install_github("darksideoftheshmoo/rcell2.examples")
}

# List of the available datasets:
dir(system.file("extdata/sample_datasets/", package = "rcell2.examples"))
```

Second, get the path to the chosen example dataset and check if the files are there:

> The dataset selected in the chunk below is a subset of a larger experiment.
> The subset contains two positions (4, 12), three time frames (10, 20, 30),
> three 'fluorescence' channels (TFP, YFP), and the mandatory BF channel.

```{r}
# Example: Choose one set of example images:
data.dir <- system.file("extdata/sample_datasets/sample_time_series/",
                        package = "rcell2.examples")
```

> In the chunk above we set up `data.dir` to hold the path to samples images of a
time-course experiment. This will replace any previous value!

A position metadata (a.k.a. `pdata`) file is also included:

```{r}
# Example: Choose one set of example images:
pdata <- system.file("extdata/sample_datasets/sample_time_series/pdata.csv",
                     package = "rcell2.examples") |> 
  read.csv()

pdata
```

## Image file names

Images are assumed to be in a single directory, and have names with identifiers for:

* Imaging channel (bright field, transmission, fluorescence, z-slice, etc.).
* Microscope position (*pos*).
* Time (*t.frame*, optional).

Cell-ID uses the first 3 letters of the file name to group imaging channels.
**This is mandatory**. If your image set does not conform initially, it can be
renamed (or symlinked) using rcell2's `rename_mda`, with custom arguments.

For example, file names for a 2-position time course experiment
are expected to have the following appearance:

```
BF_Position001_time01.tif
BF_Position001_time02.tif
TFP_Position001_time01.tif
TFP_Position001_time02.tif
YFP_Position001_time01.tif
YFP_Position001_time02.tif
BF_Position002_time01.tif
BF_Position002_time02.tif
TFP_Position002_time01.tif
TFP_Position002_time02.tif
YFP_Position002_time01.tif
YFP_Position002_time02.tif
```

The `rcell2` packages rely on regular expressions to gather images and extract 
metadata from their file names (i.e. channel, position, and time frame.)

The file list will be recognized by a specific regular expression (regex).
A regex matching these files can be `^(BF|TFP)_Position(\\d+)_time(\\d+).tif$`;
note that it has **3 capturing groups** (suff between parentheses).
The regex as a whole is used to select images from a directory (filtering out
other files) and the capturing groups are used to extract the metadata.

The `rename_mda` functions below will rename files to match the following file
pattern, which is meant for the `arguments` function. It is used to list images
from the data directory and extract metadata from the file names.

> **Note**: the usage of the "`file.pattern`" regex is explained in the
> [Arguments] section of this notebook. The next pattern will work with the
> example time-series images, and the output of `rename_mda`.
> 
> If you need to run the pre-processing steps with a different pattern,
> review the [Arguments] section of this notebook, and change it here too.

```{r}
file.pattern <- "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$"
```

### Renaming images

Metamorph's _Multi-dimensional acquisition_ (MDA for short) may use file 
names different from the usual style (i.e `far6_w2LED-BF--YFPcube--cam_s7_t2.TIF` 
instead of `BF_Position07_time02.tif`, and so on).

The `rename_mda` function renames those files names, making them compatible
with `rcell2`'s defaults. See `?rename_mda` for extra options.

The defaults are useful for a three channel experiment, 
and file names looking like this: `far6_w2LED-BF--YFPcube--cam_s7_t2.TIF`.

#### Rename all files

To run the function on all images, provide the path to the images directory.

```{r}
result <- rename_mda(images.path = data.dir,
                     # Example patterns:
                     identifier.pattern=".*_w(\\d).*_s(\\d{1,2})_t(\\d{1,2}).TIF$",
                     identifier.info = c("ch", Position="pos", time="t.frame"),
                     channel_ids = 1:4, 
                     channel_names = c("TFP", "BF", "RFP", "YFP"))
```

Update the value of the `data.dir` variable:

```{r}
data.dir <- result[["rename.path"]]
```

The defaults are easily adaptable to other cases:

- To choose names for your channels tweak `channel_ids` and `channel_names`.
- To use the function with different file name patterns, adjust `identifier.pattern`, `identifier.info`, `channel_ids` and `channel_names`. See `?rename_mda` for details.

> Note that the `channel_ids` argument on `rename_mda` must match exactly the
> text captured by the channel group in the `identifier.pattern` regex.
> Read the function's help page for details: `?rename_mda`.

#### Join multiple MDA runs

In some setups, you might end up with several image sets, from consecutive MDAs.

The full list of images can recovered and renamed to form a single image set for Cell-ID.

The `rename_mdas` is meant for this use case.

```{r}
result <- rename_mdas(images.path = data.dir,
                      # Example patterns:
                      identifier.pattern=".*_w(\\d).*_s(\\d{1,2})_t(\\d{1,2}).TIF$",
                      identifier.info = c("ch", Position="pos", time="t.frame"),
                      channel_ids = 1:4, 
                      channel_names = c("TFP", "BF", "RFP", "YFP")
                      )

result
```

The renamed images arecan be found in the following path:

```{r}
result[["rename.path"]]
```

#### Manipulating the rename mapping

A "renaming data frame" (`images.info` below) can be extracted and examined before renaming all images:

```{r}
# Set rename.function to NULL (to avoid actually copying files).
images.info <- 
  rename_mda(images.path = data.dir,
             rename.function = NULL, 
             rename.dataframe = TRUE)

images.info
```

The updated `images.info` data frame can also be adjusted and then used to rename images:

```{r}
# Example: adjust "t.frame".
images.info <- images.info |> mutate(t.frame = 99)

# Pass the updated data.frame to the "rename.dataframe" argument.
# Set rename.function to NULL (to avoid actually copying files for now).
images.info.final <- 
  rename_mda(rename.function = NULL, 
             rename.dataframe = images.info,
             file.names = one.filename)

images.info.final
```

## Preprocessing

The following sections may help improve the result of the segmentation,
to catch severe issues early on.

### Image set checks

The `arguments` function will run several tests (using `arguments_check` internally)
before returning the list of images for Cell-ID. Warnings (or errors if desired) will 
be raised if the checks fail.

```{r}
# Get images and their metadata.
image_list <- rcell2.cellid::arguments(data.dir, 
                                       check_fail = TRUE,
                                       file.pattern = file.pattern)
```

If images are missing, the command above will fail. Set `check_fail = FALSE` to 
inspect all warnings without raising an error, as exemplified below.

#### Identify missing frames

Missing images in the set can be located visually by plotting with `geom_tile`.

In this case, it is important to set `bf_as_fl = T` and `check_fail = F` in order
to get the complete image list (i.e. including `BF` as a channel), and skip errors
if images are missing (and thus the image list may be malformed).

An example follows, note that `check_fail = FALSE` is set:

```{r}
image_list <- rcell2.cellid::arguments(
  path = data.dir, 
  bf_as_fl = T,
  check_fail = FALSE,
  file.pattern = file.pattern)

d <- image_list |> 
  group_by(pos, ch, t.frame) |> 
  summarise(n=n()) |> 
  ungroup() |> 
  complete(pos, ch, t.frame)

p <- d |> ggplot() +
  geom_tile(aes(t.frame, pos, fill=!is.na(n))) +
  facet_wrap(~ch) + 
  theme_minimal()

p  # plotly::ggplotly(p)
```

After fixing any issues, re-create the arguments data frame, and move on to the
next sections.

#### Inspect sample images

Images can be opened with `magick`:

```{r}
# Install image magick.
if (!requireNamespace("magick", quietly = TRUE))
  install.packages("magick")

# Sample a few images to show, one per channel.
sample_images <- image_list |>
  arguments_to_images() |>
  group_by(channel) |> 
  filter(t.frame == min(t.frame)) |> 
  sample_n(1)

# Read and process sample images.
sample_images |> 
  with(file) |> 
  magick::image_read() |> 
  # magick::image_modulate(brightness = 400) |>
  magick::image_normalize() |> 
  magick::image_border() |> 
  magick::image_append() |> 
  magick::image_resize("700x0") |> 
  magick::image_write(path = tempfile(fileext = ".png"), format = "png") |> 
  knitr::include_graphics()
```

### Check XY stage coordinates

It may be a good idea to double check that the physical coordinates of your images
match your expectations (i.e. the column/row pairs of each well in a microscopy plate).
This information is stored in TIFF's metadata.

It requires the `ijtiff` and `XML` packages, install them by running the following:

```{r}
if(!requireNamespace("ijtiff")) install.packages("ijtiff")
if(!requireNamespace("XML")) install.packages("XML")
```

<!-- Internal note: The xml2 package does not convert the attributes automatically, 
so I stuck to the XML package. See tiff_plane_info's help and source for details. -->

#### Plot position overlaps

The following code match the images' _position_ (Pos) to their microscope stage _physical_ XY coordinates,
which are stored in the TIFF tags of the original images.

This plot is specially useful when tracing a path for positions in a multi-well time-course experiment.

It requires the `images` dataframe in `cell.data` to get the file names,
_but_ you could also use `dir` to get the files by pattern, and `sub` to get the position IDs,
independently of Cell-ID.

Optionally set details from your microscope (e.g. magnification and physical size of the camera's pixels).

```{r}
# Get images.
image_list <- rcell2.cellid::arguments(path = data.dir,
                                       file.pattern = file.pattern)

# Extract metadata and plot stage positions.
result <- image_list |> 
  # Use only the first frame
  filter(t.frame == min(t.frame)) |> 
  plot_pos_overlaps(channels = "TFP", 
                    print_plot = F)

# The plot can be found in the output list.
result$plt #|> plotly::ggplotly()
```

> If any two shaded areas overlap, there will be duplicated cells in the dataset.

We do not yet offer a way to remove them automatically. You may do this yourself
by finding the XY coordinates of the first cells not shared between images, and using
their coordinates to remove the overlapping set from one position.

#### Plot MDA's stage list

Metamorph's MDA can export a ".STG" plain-text file, containing the list of microscope positions.

It is easy to import this file and display its contents.

```{r}
stg_list_file <- system.file("stage_positions-calib_tilt_B2_top_left.STG",
                             package = "rcell2.cellid")

stg_list <- read_stg(stg_list_file)
```

```{r}
stg_list |> 
  ggplot() +
  geom_path(aes(x,y)) +
  geom_point(aes(x,y,color=af_offset), size=10, alpha =.5) +
  scale_color_viridis_c() + theme_minimal()
```

##### Fit to a plane

```{r}
stg_list_adj <- adjust_stg_z(stg_list, plot_error = T)
```


### Preview images using ImageJ

No analysis package exists (yet) that can replace a researcher's general visual assessment.

This section helps you open your images with FIJI-ImageJ before you begin.

A simple Macro can be run in ImageJ to load virtual hyperstacks of any experiment.

> Note: this macro uses a "file" pattern that only matches input images (and not ".out")
> in a tipically-named set of images.

Steps:

1. Run the following code, copy its output to the clipboard.
2. Open ImageJ/FIJI, and open a new "Macro" window by clicking on "Plugins -> New -> Macro".
3. Paste the macro into the macro editor, and click on "Run". A new hyperstack window will open.
4. Browse the images using the sliders.

```{r}
# Get images and their metadata.
image_list <- rcell2.cellid::arguments(data.dir,
                                       file.pattern = file.pattern)

# Convert the "arguments" to a list of "images" required to make the ImageJ macro.
image_list |> 
  arguments_to_images() |>
  ijm_open_hyperstack(use_out = F)
```

> Note: the dimensions names may be mismatched between R and the macro if `fix_order=F`. 
> This is because virtual stacks must be in `xyczt` order (time is likely to end up as the "channels" dimension),
> but the order in which the "Image Sequence..." is loaded depends on how their files are named.

The only restriction of this approach is that only "3" dimensions are available for
browsing: `frame`, `plane`, and `channel`. This is relevant if you wish to browse
segmentation results (which adds another dimension to the set: "original" vs "out").
A fourth dimension would be needed, but Hyperstacks only provide 3. The default is to
load "out" files as new channels.

#### Tagging cells

The "multi-point" tool in ImageJ can be used to mark cells with different "counters",
by simply clicking on them in the image.

These marks can be exported and mapped back to `ucid`s in R, and then
used for filtering and analysis.

Steps:

1. Open the images in a Hyperstack, as described in the [Preview images using ImageJ] section.
2. Use the multi-point tool to mark individual cells with one or more "counters", as required by your experiment.
3. After tagging the cells, generate the measurements (press `Ctrl+M`) and save
   them to a `.csv` file (press `Ctrl+S`, or `File -> Save`).
  - It is critical that you check that the values of the "Ch" (channel), 
    "Slice", and "Frame" ImageJ measurements map correctly to `t.frame`s,
    `pos`, and `ch` in Cell-IDs output.
  - Note that ImageJ's time indexes begin at 1, but Cell-ID's 
    begin at 0. This may need to be adjusted later.

Detailed instructions on how to import these points and map them to cells 
identified by Cell-ID, can be found in the [Cell-tagging using ImageJ] section
of this notebook.

#### Reordering images

Images can be reordered images in the hyperstack by replacing the "position" column, which
normally reflects the order in which images were acquired (i.e. first, second, etc.).

For this purpose you'll need a `pdata` file with the experiment's original stage _position_ metadata,
and then override its `pos` index.

> An example `pdata` can be obtained from the examples package (see the [Use the examples] section of this notebook).

In this example, the `pdata` is sorted by strain and stimulus concentration, and
this new order is used to override the `pos` indexes.

```{r}
new_pdata <- pdata |> 
  arrange(desc(yeast_strain), pheromone_concentration) |> 
  mutate(
    # Backup the original order.
    old_pos=pos, 
    # Make a new order.
    pos = 1:n()) |> 
  arrange(pos)

new_pdata
```

Now you can generate a new ImageJ macro to open and browse the images with the new order:

```{r}
image_list_sorted <-  image_list |> 
  arguments_to_images() |> 
  dplyr::rename(old_pos = pos) |> 
  left_join(new_pdata |> select(old_pos, pos), by = join_by(old_pos)) |> 
  select(-old_pos)

image_list_sorted |>
  ijm_open_hyperstack(use_out = F)
```

The new order can be checked against the physical stage coordinates in the images metadata:

```{r}
tfp_images <- image_list |> 
  arguments_to_images() |> 
  filter(channel == "TFP")

new_pos_coords <- tfp_images |> 
  get_plane_info() |> 
  left_join(tfp_images) |> 
  select(pos, stage.position.x, stage.position.y) |> 
  dplyr::rename(old_pos = pos) |> 
  left_join(new_pdata) |> 
  arrange(pos)  # arrange(old_pos)

plt <- new_pos_coords |> 
  ggplot(aes(stage.position.x, stage.position.y)) + 
  geom_path() +
  geom_point(aes(color=as.factor(pos), 
                 shape=as.factor(yeast_strain), 
                 text=paste("Old pos:", old_pos),
                 size=pheromone_concentration)) +
  scale_x_reverse()

# plt |> plotly::ggplotly()
plt
```

### Check acquisition times

Acquisition times can be extracted from metadata in the TIFF files produced by MetaMorph.

```{r}
# Get images.
image_list <- rcell2.cellid::arguments(path = data.dir,
                                       file.pattern = file.pattern) |> 
  suppressWarnings()
```

Extract time information for the BF channel only:

```{r}
time_info <- get_time_info(image_list = image_list, channels = "BF")
```

> Note that ImageJ's FFT filter will not add MetaMorph's metadata to the filtered BFs.
> This means that `get_time_info` will only work on the original TIFF files.

Distribution of time intervals:

```{r}
time_info |> filter(pos == first(pos)) |> 
  with(acquisition.time.ct) |>as.numeric() |> diff() |> 
  hist(main="Distribution of time interval between frames", 
       xlab="Interval time (seconds)")
```

`t.frame` plotted against the acquisition time difference should be completely flat,
if acquisition intervals were perfectly even.

```{r}
time_info |> 
  # Compute acq. time differences by position.
  group_by(pos) |> arrange(t.frame) |>
  mutate(acq_delta=c(NA, diff(acquisition.time.ct)))  |> 
  # Plot.
  ggplot(aes(t.frame, acq_delta, color=as.factor(pos), group=pos)) +
  geom_line() + 
  ylim(c(0, NA)) + ylab("Minutes since last frame") + #guides(color=F) +
  ggtitle("Elapsed time between frames")
```

This plot will show the actual local time for each image frame, and should be diagonal:

```{r}
time_info |> 
  ggplot(aes(acquisition.time.ct, t.frame)) +
  geom_line() + 
  facet_wrap(~pos) +
  ggtitle("Acquisition time vs Image frame index")
```

### Apply FFT filter on BF images

Optionally, use ImageJ's band-pass FFT filter on the defocused bright field images.

This can help Cell-ID find cells and reduce background artifacts.

List the BF images from the `arguments` function:

```{r eval=F}
# Get image paths
cellid.args <-
  rcell2.cellid::arguments(path = data.dir,
                           file.pattern = file.pattern)
```

The `run_fft_filter_on_bfs` will launch ImageJ in the background and apply the FFT filter on a copy of the images.

In brief, it will:

- Split the BF files by position, and symlink them to different subdirectories.
- Run FFT filter in parallel using a macro, with one ImageJ instance per subdirectory.
- Symlink filtered BFs from each subdirectory to a single "filtered" images directory.
- Symlink the rest of the images (i.e. fluorescence images) to the "filtered" directory.

Run the filter:

```{r eval=F}
new.data.dir <- run_fft_filter_on_bfs(
  data.dir = data.dir,
  cellid.args = cellid.args,
  # imagej.path="~/Software/ImageJ/Fiji.app/ImageJ-linux64") # Adjust to your system
  imagej.path="~/Software/ImageJ-FIJI/Fiji.app/ImageJ-linux64") # Adjust to your system

new.data.dir
```

You can run Cell-ID using the new directory as the new `data.dir`:

```{r eval=F}
data.dir <- normalizePath(new.data.dir)
```

## Segmentation

In this section we will prepare arguments for Cell-ID and segment cells in images.

### Parameters

First we must configure the Cell-ID parameters that affect cell segmentation, 
tracking, and some corrections.

#### Descriptions

Show a data.frame with the description of each Cell-ID parameter:

```{r}
parameters_help_df
```

Also available in list format:

```{r}
parameters_help$max_dist_over_waist
```

#### Values

Here is a valid, _hand-made_ parameter list, with the defaults I like:

```{r eval=F}
parameters.list <- list(
  max_split_over_minor = 0.50,
  max_dist_over_waist = 8.00,
  max_pixels_per_cell = 2000,
  min_pixels_per_cell = 75,
  background_reject_factor = 0.75,
  tracking_comparison = 0.20,
  align_individual_cells = F,
  align_fl_to_bf = T,
  image_type = "brightfield",
  bf_fl_mapping = "list"
  )
```

Fortunately you don't have to do this by hand. `parameters_default` is a helper 
function to prepare the parameters list more easily, and also documents them 
(run `?parameters_default` to learn more).

Lets use the `parameters_default` function to generate all the required 
parameters, overriding only the value of the `background_reject_factor` parameter:

```{r}
parameters.list <- 
  rcell2.cellid::parameters_default(
    background_reject_factor = 0.4
  )

parameters.list$background_reject_factor
parameters.list$max_split_over_minor
```

#### The file

> *Note*: This section is no longer critical. The `arguments` function also 
> accepts a list of parameters, or a > `data.frame` with position numbers and 
> paths to parameter files. See `?arguments` for details

This parameter list must be written to a `parameters.txt` plain text file with 
the proper syntax, which Cell-ID will read later on.

For this purpose, you may use the `parameters_write` function. As its name 
implies, it writes the parameters, and returns the path where it was saved.

<!-- Internal note: consider moving this step into cell2() -->

```{r}
parameters.txt <- rcell2.cellid::parameters_write(parameters.list)

parameters.txt
```

This path can be passed to the `arguments()` function in the next section.

Lets read the contents of the `parameters.txt` file we just saved.

```{r}
# Mostrar el contenido del archivo
writeLines(readLines(parameters.txt))
```

### Arguments

The `arguments` function outputs a `data.frame` with information from images and
segmentation parameters, which is needed to run Cell-ID.

The key parameter is `file.pattern`, a regular expression used to find image
files in the `data.dir` folder.

The path to the images of your experiment must be already defined,
as explained in the [Path to the dataset] section of this notebook.

#### Image file pattern

By default, `arguments` uses the following pattern:

    "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$"

Note that enclosed in parentheses are the "capture groups" of the regular expression.
These delimit the parts of the file name which contain identifiers for:

1. Imaging channel (`ch`).
2. Stage position index (`pos`).
3. Time-frame index (`t.frame`).

If your experiment has a single time frame, and it is not part of the file names,
the content of the corresponding capturing group can be deleted (leaving the
empty parenthesis in place):

    "^(BF|[A-Z]FP)_Position(\\d+)().tif$"

The regular expression can be used to select or filter out sets of images (
though it will be often easier to use R's tool for this). To select only position
with index "2", and times 2, 3 and 4, use:

    "^(BF|[A-Z]FP)_Position(0*2)_time(0*[423]).tif$"

> Note the `0*` in front of numbers. This indicates that there might me be leading
> zeros in front of the position and time identifiers.

If the identifiers on your file names appear in a different order, either rename them as
shown in the [Renaming images] section, or reorder the default `file.pattern.groups.order`
in the call to `arguments`.

Note, however, that the channel identifier _must_ be first. Cell-ID will use the
**first three letters** to distinguish and group imaging channels.

> **Important**: the patterns used in `arguments` must match the ones used in
> `get_cell_data` when loading Cell-ID's output (later on).

Images file pattern examples; choose one and comment the others:

```{r}
# Default value: all channels, no z-stack.
arguments.file.pattern <- "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$"

# To consider z-stacks:
# arguments.file.pattern <- "^(BF|[A-Z]\d+)_Position(\d+)_time(\d+).tif$"

# BF or TFP only, no t.frame info.
# arguments.file.pattern <- "^(BF|TFP)_Position(\\d+)().tif$"
```

Learn more by opening the help page of the `rcell2.cellid::arguments` function.

#### Usage

Now, load image file names from a `data.dir` directory, with names matching the
`arguments.file.pattern` regular expression, and set segmentation `parameters`:

```{r}
cellid.args <- rcell2.cellid::arguments(
  # Path to the images.
  path = data.dir,
  # File pattern to recognize the images.
  file.pattern = arguments.file.pattern,
  # Parameters are specified here.
  parameters = parameters.list
)

cellid.args
```

You can filter out or select certain image sets at this stage:

```{r}
cellid.args %>% filter(pos == 2, t.frame %in% c(4,2,3))
```

#### Nuclear or Vacuolar tags

Images containing the location of the nucleus or vacuole can be used
to derive extra measurements from those structures.

A "third" image list must be added to the arguments. In the following example,
the YPF channel is added to the arguments to a new column named "`third`" exactly.

```{r}
# Optionally Add "third" column
cellid.args <-  left_join(
  cellid.args,
  cellid.args %>% filter(ch == "YFP") %>% select(pos, t.frame, image) %>% rename(third = image)
)
```

The `cell2` function will look for this column and pass the images to Cell-ID if found.

To enable this feature in Cell-ID, the parameters must have been 
also configured (see `?parameters_default`) by setting `third_image` to
"vacuole_label" or "nuclear_label".

### Tuning parameters

Sometimes we want to test out many parameter combinations 
before running Cell-ID in the full dataset.

> If you use Cell-ID often, your cells' morphologies do not change dramatically,
> and you are using the same microscope as the last time, you may be better off 
> reusing those parameters and skipping this section.

This functionality requires the `magick` R package,
and ImageMagick on your system (which can be obtained 
[here](https://imagemagick.org/script/download.php)). 

Run the following to install the R package if absent:

```{r}
if(!requireNamespace("magick")){
  install.packages("magick")
}
```

#### Setup

Prepare the patterns and arguments as usual (if not done already):

```{r}
# Default value: all channels, no z-stack.
arguments.file.pattern <- "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$"

# Get full image list
cellid.args <- rcell2.cellid::arguments(path = data.dir,
                                        file.pattern = arguments.file.pattern)
```

##### Image set

Choose which of the image sets in `cellid.args` you wish to use for the parameter scan.

For example, choose some *positions* (image sets) and *t.frame*s (time frames)
to restrict the image test set to only some of them.

Some guidelines:

1. Choose at least one image and frame from a "control" situation.
2. Choose at least one image and frame from a "treated" situation, where cells might vary in morphology.
  - A much later time, with larger cells.
  - Treated cells, which might show shmoos.
3. Choose more than one consecutive frame to asses the stability of your segmentation parameters over adjacent frames.

```{r}
# Choose test positions, frames and channels.
test.pos = unique(cellid.args$pos)[1]        # e.g.: One position.
test.frames = unique(cellid.args$t.frame)[1] # e.g.: One frame.
test.chs = unique(cellid.args$ch)[1]         # e.g.: One channel.

# Filter cellid.args to choose image sets for the scan
scan.arguments <-  
  subset(cellid.args, 
         pos %in% test.pos & t.frame %in% test.frames & ch %in% test.chs)

# Examine the subset
scan.arguments
```

##### Parameter sets

For each parameter variation, we need a new parameters file. The simplest way to
generate parameter combinations is with rcell2's `parameters_default` and R's `expand.grid`.

Because scanning over all parameters space would take ages, you can follow a 
simplified procedure of 3 small scans, on a small subset of images. 

Here is a procedure to reduce the scan's complexity:

0. Relax segmentation parameters:
  - Set `max_split_over_minor` and `max_pixels_per_cell` to high values (e.g. `5` and `5000`).
  - Set `min_pixels_per_cell` to a low value (e.g. `30`).
1. First scan over `background_reject_factor` *only* (e.g. between `0` and `2`).
  - Set `background_reject_factor` to its optimal value, which maximizes 
    detection of cells, and minimizes segmentation artifacts.
3. Scan over `max_dist_over_waist`.
4. Fix `max_dist_over_waist` to its optimal value, which adjacent cells and 
   daughters cells from their mothers.
  - At this point you must tolerate projected growth (i.e. shmoos) being split 
    from the rest of the cell body.
5. Scan over `max_split_over_minor` *only*, which should minimize the amount of 
   growth projections split from their bodies.

> Do not skip the first step, is will make the interpretation of parameters simpler.
> For example, `max_dist_over_waist` can split "figure-8" cells into two,
> and `max_split_over_minor` will re-join shmoo-like cells that were split,
> possibly masking the effect of the first.
> Furthermore, "split" small cells and "joined" large cells can be removedby the
> pixel limits. 

In the following example, only `background_reject_factor` is scanned, across 
values produced with R's `seq` function:

```{r}
parameters.list <- rcell2.cellid::parameters_default(
  background_reject_factor = seq(from=0, to=1.5, by = 0.4)
)

parameters.list$background_reject_factor
```

The parameters list must now be expanded into a data.frame, 
with a row for every possible combination of parameter values:

```{r}
parameters.df <- expand.grid(parameters.list)

parameters.df
```

> Note: You might want to select some rows from that table. In that case, simply filter it.

##### Test directory

Define working paths for parameter scanning:

* `data.dir`: directory with the original images (they will not be modified).
* `test.dir`: directory for temporary files of the tuning process.

```{r}
# Set your own path, or uncomment the following to use example images.
# data.dir <- system.file("extdata/sample_datasets/sample_time_series/",
#                         package = "rcell2.examples")

# The output of the parameter scan will be saved here:
test.dir <- file.path(tempdir(), "images_directory", "test.dir")
test.dir
```

#### Run the Scan

> Now comes the magic part.

The `parameter_scan` function uses temporary directories to work on images, 
and avoids messing up the main data directory, 
while running Cell-ID in parallel for each parameter variation.

Just run:

```{r eval=F}
scan.results <- 
  parameter_scan(parameters.df = parameters.df,
                 # Optionally choose the temporary output directory by setting "test.dir".
                 scan.arguments = scan.arguments)
```

> Have a look at the function's source code if you like, its hopefully well commented.

#### Review result in ImageJ

Prepare virtual TIFF stacks for a one or more imaging channels, with the `make_scan_stacks` function.

To help the user choose a parameter set, the stacks are annotated with the parameters used
for the segmentation, and other metadata (position, time frame, and channel).

There are two alternatives: `annotate_scan_output` and `make_scan_stacks`. The first will
annotate the images and save them, and the latter will annotate the images and save them
to a stack. Note that making a stack can consume all your system's RAM if the scan is 
moderately large. We recommend using `annotate_scan_output`.

A copy-paste-ready ImageJ Macro will be printed out by either function, 
to easily load the stacks as virtual Hyperstacks in ImageJ.

**Option A**: `annotate_scan_output`

This function will annotate individual images, save them, and compose an ImageJ
macro, to inspect them in a single _virtual_ stack.

The macros are printed to the console, and are also available in the output 
of `annotate_scan_output`.

> **Tip**: copy-paste the macro to a new macro window in ImageJ, and hit run!
> The stack should be loaded auto-magically.

```{r}
imagej_macros <- annotate_scan_output(scan.results = scan.results, 
                                      in.place = FALSE,
                                      preserve_source_imgs = TRUE,
                                      annotated.imgs.dir = "annotated",
                                      annotation.font = "Hack")
```

**Option B**: `make_scan_stacks`

This function will make TIFF stacks, which can take a long time if the image
set is large, but are easier to open (i.e. without a macro).

```{r eval=F}
stack.paths <- 
  make_scan_stacks(scan.results = scan.results, 
                   stack.channels = "BF.out")
```

Paths and macros are available in the output of `make_scan_stacks`:

```{r}
names(stack.paths)
```

```{r}
stack.paths$stack.paths
```

```{r}
stack.paths$imagej.macros
```

#### Useful Plots

A few quantities are calculated for each run of the scan, which can be 
indicative of segmentation quality, and may be useful for selecting parameters 
programatically (i.e. without visual inspection with ImageJ/FIJI).

* Cell-ID variables:
  * `fft`
  * `el.p`
  * and so on...
* Derived measures:
  * `ucids`: Total amount of distinct `ucid`s. Increases with segmentation artifacts and unstable tracking.
  * `persistence`: Average number of time frames per cell. Correlates with stable segmentation and tracking.
  * `roughness` & `roughness2`: Indicative of the average "roughness" in the evolution of `a.tot` across time frames.

<!-- Internal note: TO-DO: add explanations of these quantitites. -->

The average of these quantities may be useful for selecting optimal parameters.
A few of combinations these are plotted below.

First get the output data frame from the scan results:

```{r}
results.bound <- scan.results$results.bound
```

You can then start making a few plots.

```{r}
# Avg. frames per cell (persistence) VS 'el.p/fft' per parameter variation
results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(persistence, el.p/fft, label = id,
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. frames per cell (persistence) VS 'el.p/fft' per parameter variation") +
  theme_minimal() + scale_color_discrete()

# Avg. frames per cell (persistence) VS 'el.p/fft' per parameter variation
results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(persistence, el.p/fft, label = id,
                 color = as.ordered(max_split_over_minor)),
             alpha = .7, fill = "NA") +
  ggtitle("Avg. frames per cell (persistence) VS 'el.p/fft' per parameter variation") +
  theme_minimal() + scale_color_discrete()
```

And more plots:

```{r}
# Avg. el.p VS Avg. fft.stat per parameter variation
results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(el.p, fft, label = id,
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. el.p VS Avg. fft.stat per parameter variation") +
  theme_minimal() + scale_color_discrete()

# Avg. roughness per cell VS Avg. frames per cell (persistence) per parameter variation
results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(roughness, persistence, label = paste0(id, "=", background_reject_factor),
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. roughness per cell VS Avg. frames per cell (persistence) per parameter variation") +
  theme_minimal() + scale_color_discrete()

# Avg. roughness2 per cell VS Avg. frames per cell (persistence) per parameter variation
results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(roughness2, persistence, label = paste0(id, "=", background_reject_factor),
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. roughness2 per cell VS Avg. frames per cell (persistence) per parameter variation") +
  theme_minimal() + scale_color_discrete()
```

#### Final parameter set

This parameter set was chosen for FFT-filtered BFs.

Under 0.8 background_reject_factor, there were some "persistent" _ghosts_;
elongated _chorizos_ on the sides of cells.

```{r eval=F}
parameters.list <- rcell2.cellid::parameters_default(
  background_reject_factor = 0.8,
  max_split_over_minor = 0.6,
  max_dist_over_waist = 6,
  max_pixels_per_cell = 3500,
  treat_brightfield_as_fluorescence_also = T
)
```

#### Recreate arguments

Arguments for Cell-ID must be recreated to use the updated parameters instead.

```{r}
parameters.txt <- rcell2.cellid::parameters_write(parameters.list)

cellid.args <- rcell2.cellid::arguments(data.dir,
                                        file.pattern = arguments.file.pattern,
                                        parameters = parameters.txt)  # Parameters are specified here.

cellid.args
```

### Run Cell-ID

The `cell2` function generates system commands to run Cell-ID,
and executes them in parallel by default.

> *Tip*:
> `n_cores` can be set to the number of CPU cores you want to use to parallelize
> the segmentation (relying on `foreach`). It defaults to use all but one of the
> available cores.

> **Warning**: existing output files **will be overwritten** without warning. 
> To check if this will happen before running `cell2`, run `arguments_check(cellid.args)`.
> It will check if any output files exist and print messages to the console.

```{r eval=F}
cell2.result <- rcell2.cellid::cell2(arguments = cellid.args, 
                                     output_coords_to_tsv = T)
```

The `cell.command` argument must be the path to the Cell-ID binary executable.
In this version of `rcell2`, it defaults to `NULL`, and the bundled executable 
is used.

> *Tip*:
> Run `?cell2` to read about advanced segmentation parameters, You can, for example,
> set flags to generate additional output files with segmentation masks or 
> identified cell-boundary pixel coordinates.

#### Review segmentation in ImageJ

This section helps you open your images with FIJI-ImageJ to review the resulting segmentation.

A simple Macro can be run in ImageJ to load virtual hyperstacks of any experiment.

> *Note*: this macro uses a "file" pattern that only matches output images (i.e. "tif.out.tif")
> in a tipically-named set of images.

Steps:

1. Run the following code, copy its output to the clipboard.
2. Open ImageJ/FIJI, and open a new "Macro" window by clicking on "Plugins -> New -> Macro".
3. Paste the macro into the macro editor, and click on "Run". A new hyperstack window will open.
4. Browse the images using the sliders.

```{r}
ijm_open_segmentation(cellid.args)
```

> *Note*: the dimensions names may be mismatched between R and the macro. This is because 
virtual stacks must be in `xyczt` order (time is likely to end up as the "channels" dimension), 
but the order in which the "Image Sequence..." is loaded depends on how their files are named.

The only restriction of this approach is that only "3" dimensions are available for
browsing: `frame`, `plane`, and `channel`. This is relevant if you wish to browse
segmentation results (which adds another dimension to the set: original vs "out").
A fourth dimension would be needed, but Hyperstacks only provide 3. Alternatively, 
open another virtual hyperstack for the output images, and browse them in-sync.


### Output data

Cell-ID's output consists mainly of:

* Segmented images (named with the `.out.tif` suffix).
  * *Optional:* "BF.out" images with identified binary masks.
* Tables with single-cell quantitative information (from their morphology and fluorescence).
  * *Optional:* Compressed tables with the boundary and interior pixels of identified cell.

#### Output file pattern

File patterns for the image set may vary slightly; depending on what images were 
provided as input, and the identifiers in their file names.

The pattern must match file names of fluorescent images, and have a capturing group
for the channel identifier (e.g. `YFP`, `GFP`, etc.).

The most common fluorescent channel patterns for `get_cell_data` and `parameter_scan`
are defined below.

Choose one pattern and comment the others:

> Note: your `fluorescence.pattern` regex may vary.

```{r}
# Default value: all fluorescent tags, including Z-stack fluorescence channels.
fluorescence.pattern <- "^([GCYRT]FP|[GCYRT]\\d+)_Position\\d+_time\\d+.tif$"

# Default: add "BF" as a possible channel (when Cell-ID was run with bf_as_fl=TRUE)
# fluorescence.pattern <- "^([GCYRT]FP|[GCYRT]\\d+|BF)_Position\\d+_time\\d+.tif$"

# Same as default, but without t.frame information.
# fluorescence.pattern <- "^([GCYRT]FP|[GCYRT]\\d+)_Position\\d+.tif$"
```

List files that match the pattern, to check that it works as expected:

```{r}
data.dir %>% 
  dir(pattern = fluorescence.pattern) |> 
  sample() |> 
  head()
```

#### Load the output

The output tables can be loaded with `get_cell_data`.

```{r eval=F}
# Load output
cell.data <- rcell2.cellid::get_cell_data(path = data.dir,
                                          fluorescence.pattern=fluorescence.pattern)
```


Alternatively, function `load_cell_data` from `rcell2` can load those tables as well.

```{r eval=F}
# Install rcell2's main analysis package if unavailable.
if(!requireNamespace("rcell2")){
   devtools::install_github("darksideoftheshmoo/rcell2")
}

# Load output
cell_data <- rcell2::load_cell_data(path = data.dir)
```

#### Load cell boundaries

Both `rcell2.cellid` and `rcell2` provide the `cell.load.boundaries` function, which can 
load the cell boundaries and interior pixels coordinates.

This data is only available if either `output_coords_to_tsv` or `encode_cellID_in_pixels` 
were set to `TRUE` when Cell-ID was run.

To load the boundary pixels, use the `cell.load.boundaries` function. It can load this 
information from two kinds of sources:

* "`masks.tsv`": from TSV files, available if Cell-ID was run with `output_coords_to_tsv=TRUE`.
* "`out.tif`": from binary masks in TIFF files, available if Cell-ID was run with `encode_cellID_in_pixels=TRUE`.

```{r eval=F}
# Useful if either "output_coords_to_tsv" or "encode_cellID_in_pixels" were TRUE in cell().
cell.boundaries <- 
  rcell2.cellid::cell.load.boundaries(
    data = cellid.args,
    data_source = "masks.tsv",
    pixel.type = "b"
  )
```

#### Variable descriptions

To help understand Cell-ID's output, we documented the descriptions of variables
available in the `cell.data$data` data frame.

They are available in `output_help` and `output_help_df`:

```{r}
rcell2.cellid::output_help_df
```

## Export results to RDS files

The two main objects in `cell.data` are the `data` and `images` data frames, containing
measurements of individual cells and metadata about the image set of the experiment.

These data frames are used in downstream analyses with `rcell2` and `rcell2.magick`, 
and are often referred to as `cdata` and `paths` respectively.

You may optionally export these to individual RDS files.

```{r}
# Save the full cell.data object to an RDS file.
cell.data |> 
  saveRDS("data/cell.data.RDS")

# Save cdata to an RDS file.
cell.data |> with(data) |> 
  saveRDS("data/cdata.RDS")

# Save images to an RDS file.
cell.data |> with(images) |> 
  saveRDS("data/images.RDS")
```

If you export the results to RDS files, you can load them later on using `readRDS`.

## Cell-tagging using ImageJ

The `tagCell` function from the `rcell2.magick`` can provide a randomized experimental context 
for tagging (i.e. a _pseudo_ double-blind experiment).

If bias during tagging is not a concern, the "multi-point" tool in ImageJ can
be used to mark cells with different "counters", by simply clicking on them.

These marks can be imported to R, and then used for analysis.

### ImageJ Hyperstack

This section helps you open your images with FIJI-ImageJ before you begin.

A simple Macro can be run in ImageJ to load virtual hyperstacks of any experiment.

_Note_: You can skip this part and proceed to the [Import Multipoints] section 
if you have already tagged your cells, as described in the [Tagging cells] section.

Follow these steps to open images in ImageJ.

1. Run the following code, and copy its output to the clipboard.
2. Open ImageJ/FIJI, and open a new "Macro" window, by clicking on "Plugins -> New -> Macro".
3. Paste the macro into the macro editor, and click on "Run" below. A new hyperstack window will open.
4. Browse the images using the sliders.

Follow these steps to tag cells in ImageJ.

5. Use the multi-point tool to mark individual cells with one or more "counters".
6. After tagging the positions make measurements (press Ctrl+M) and save
   the output to a `.csv` file.
  - It is critical that you check that the values of the "Ch" (channel), 
    "Slice", and "Frame" ImageJ measurements map correctly to `t.frame`s,
    `pos`, and `ch` in Cell-IDs output.
  - Note that ImageJ's indexes begin at 1, but Cell-ID's begin at 0. This is
    specially relevant for `t.frame`s.

```{r}
rcell2.cellid::ijm_open_hyperstack(images)
```

> Note: the files are symlinked with new names to a temporary directory, to save
> space, and will only survive during this R session. Next time you want to open 
> the images, run the `ijm_open_hyperstack` function again.

The only restriction of this approach is that only "3" dimensions are available for
browsing: `frame`, `plane` (Slice), and `channel`. This is relevant if you wish to browse
segmentation results (which adds another dimension to the set: original vs "out").
A fourth dimension would be needed, but Hyperstacks only provide 3. Alternatively, 
open another virtual hyperstack for the output images, and browse them in-sync.

### Import Multipoints

If you tagged cells and exported the multi-points to CSV files, this section
explains how to load them into R, and map them to Cell-ID's positions and time 
frames.

7. Import the Multi-point tags using the code below.

Specify the directory where the measurements were saved, and a regular-expression
pattern to select only the relevant files.

```{r}
results.dir <- ".../somewhere/over/the/measurements/"

results.pattern <- "Results.*.csv"
```

You can now list the CSV files:

```{r}
mp.filters.files <- dir(path = results.dir, 
                        pattern = results.pattern, 
                        full.names = T)

mp.filters.files
```

Check that these are the files you need, and then load them into R:

```{r}
mp.filters <- 
  # Load CSV files
  mp.filters.files |> lapply(read_csv) |> 
  # Bind rows
  bind_rows() |> 
  # Get position info from the "Slice" index..
  mutate(pos = Slice) |> 
  # Cleanup
  select(pos, X, Y, Ch, Slice, Frame, Counter) |> 
  # Add an ID to each tag
  mutate(mpid = 1:n())
```

8. Re-index the time frame column to match Cell-ID's.

```{r}
mp.filters <- mp.filters |> 
  # Re-index t.frame by subtracting 1.
  mutate(t.frame = Frame - 1)
```

9. _Optional_: Prepare a `data.frame` with tag names mapped to _Counter_ indices, and join it to the points data frame.
  - Note that ImageJ's Multi-point counters begin at 0.
  - Each "Counter" has an associated "tag", corresponding to the event or class marked in the images.
  
```{r}
# For example:
counter.desc.df <- data.frame(
  Counter = 0:3,
  tag_description = c("Ok", "Budding", "Dead", "Spurious")
)

# Uncomment for effect:
# mp.filters <- mp.filters |> 
#   left_join(counter.desc.df)
```

10. Examine the result.

```{r}
mp.filters
```

#### Sample dataset

Here is an example `mp.filters` `data.frame`. In this case the position 
is encoded in the _Slice_ variable.

```{r}
mp.filters.file <- system.file("extdata/sample_datasets/sample_time_series/imagej_mp_tags/results_pos4_12.csv",
                               package = "rcell2.examples", mustWork = T)

mp.filters <- 
  # Load CSV files
  mp.filters.file |> read_csv() |> 
  # Cleanup
  select(X, Y, Ch, Slice, Frame, Counter) |> 
  # Add an ID to each tag
  mutate(mpid = 1:n()) |> 
  # Re-index t.frame by subtracting 1.
  mutate(t.frame = Frame - 1)

mp.filters
```

### Map points to cells

Keep the relevant set of counters (a.k.a. markers) from the `mp.filters` data frame.

```{r}
mp.filters <- 
  # Load CSV files
  mp.filters.files |> lapply(read_csv) |> 
  # Bind rows
  bind_rows() |> 
  # Get position info from the "Slice" index..
  mutate(pos = Slice) |> 
  # Cleanup
  select(pos, X, Y, Ch, Slice, Frame) |> 
  # Add an ID to each tag
  mutate(mpid = 1:n())

mp.filters
```

Calculate distance from each cell to its closest multipoint, and save it's ID:

```{r}
# Make a copy of cdata
cdata.mp <- cdata |>
  # filter(t.frame == min(t.frame)) |> 
  select(ucid, pos, t.frame, xpos, ypos)

# Make a copy of the points
mp.mapped <- mp.filter

# Add the columns
mp.mapped[, c("ucid", "closest.dist")] <-
  apply(mp.filter, 1, function(x){
    cells <- filter(cdata.mp, pos == x["pos"] & t.frame == x["t.frame"])
    
    if(nrow(cells) == 0) return(c(NA, NA))
    
    dists <- sqrt(( (x["X"]-cells$xpos)^2) + ((x["Y"]-cells$ypos)^2) )
    
    if(length(dists) == 0) return(c(NA, NA))
    
    min.id <- cells$ucid[which.min(dists)]
    
    c( min.id, min(dists))
  }) |> t()

mp.mapped
```

Fix mis-assgnments manually here:

> If you spot any mis-assignments later, you can fix them here mannualy and then re-inspect.

```{r}
# mp.mapped[mp.mapped$ucid==110047,"ucid"] <- 110754
# 
# mp.mapped
```

Join the closest points to `cdata.mp`:

```{r}
mp.mapped.minimal <- mp.mapped |> 
  select(mpid, ucid, t.frame, closest.dist, Counter)

cdata.mp <- cdata.mp |> 
  inner_join(mp.mapped.minimal) |> 
  dplyr::rename(closest.mp.id=mpid)
```

Examine images of the tagged cells: 

```{r}
cdata.mp |>
  rcell2.magick::magickCell(images) |> 
  rcell2.magick::magickForKnitr()
```

Plot the point's distribution, this will help you choose an appropriate threshold.

```{r}
mp.mapped.minimal |> 
  ggplot(aes(closest.dist)) + 
  geom_histogram() +
  facet_wrap(~Counter)
```

### Filtering cells

You can set a threshold distance, and create a filter column:

> This value will depend on you optical setup, and the morphology of your cells.

```{r}
threshold <- 11

cdata.mp$has.close.mp <- cdata.mp$closest.dist < threshold
```

Plot the result:

> You may find `plotly::ggplotly` useful to render this plot in interactive form.

```{r}
p <- ggplot() + 
  geom_point(aes(xpos, ypos, 
                 color="CellID",
             text=paste("ucid:", ucid, ", closest dist:", closest.dist)),
             data=cdata.mp) +
  
  geom_point(aes(X, Y, color="ImageJ"), 
             data = mp.filter, 
             size = 3) +
  
  geom_point(aes(xpos, ypos, color="matched"),
             data=cdata.mp |> filter(has.close.mp)) +
  
  facet_wrap(~pos) + coord_equal() +
  ggtitle(paste0("Examine MP filter result", " (d<", threshold, ")"), 
          "Black: ImageJ points; Gray: all Cell-ID cells; Red: Cell-ID cells matched to a point.") + 
  
  scale_color_manual(values=c(ImageJ="black", matched="red", CellID="grey")) +
  scale_y_reverse() +
  theme_minimal()

# plotly::ggplotly(p)
p
```

Examine images of the filtered cells: 

```{r}
cdata.mp |> filter(has.close.mp) |> 
  rcell2.magick::magickCell(images) |> 
  rcell2.magick::magickForKnitr()
```

Examine images of the un-matched points: 

```{r}
# Make a cdata-like data frame for magickCell.
unmatched.points <- mp.filters |> 
  dplyr::rename(xpos=X,ypos=Y) |> 
  inner_join(
    mp.mapped.minimal |> 
      filter(closest.dist >= threshold) |> 
      select(-t.frame),
    by = "mpid"
  )

# Display some images.
unmatched.points |> 
  rcell2.magick::magickCell(images) |> 
  rcell2.magick::magickForKnitr()
```

### Find duplicates

Generate indicator column:

```{r}
cdata.mp$n_dupes <- apply(X = cdata.mp, MARGIN = 1, function(cell){
  sum( (cell["closest.mp.id"] == cdata.mp$closest.mp.id) & cdata.mp$has.close.mp )
})

cdata.mp$dupes <- cdata.mp$n_dupes > 1

any(cdata.mp$dupes) # Should be false
unique(cdata.mp$n_dupes) # Should be only 1's and 0's.
```

> `n_dupes` is 1 if the `ucid` was assigned to 1 mpid. If greater than 1,
> the `ucid` shares the mpid with at least anoher `ucid` (and this should
> not happen).

Check graphically:

```{r}
plt.dupes <- ggplot() + 
  
  geom_point(aes(X, Y, shape = Counter), color = "gray",
             data = mp.filter |> mutate(Counter = as.factor(Counter)), 
             size =3) +
  
  geom_point(aes(xpos, ypos), color = "black", data = cdata.mp) +

  geom_point(aes(xpos, ypos, color=as.factor(n_dupes)),
             data = cdata.mp |> filter(has.close.mp)) + 
    
  geom_line(aes(xpos, ypos, group=closest.mp.id), color = "black",
            data = cdata.mp |> filter(has.close.mp)) + 
  
  ggtitle("Graphical check of unique matches",
          "The points from cdata sharing a close multipoint are joined by lines") +
  
  facet_wrap(~pos)

plotly::ggplotly(plt.dupes)
```

Tabular check. There should be only one row for each `closest.mp.drop.id`.

```{r}
checks.df <- cdata.mp |> 
  group_by(closest.mp.id) |> 
  filter(has.close.mp) |> 
  summarise(row.count = n()) |> 
  arrange(-row.count)

all(checks.df$row.count == 1)  # Should be TRUE
```

Manual inspection:

```{r}
checks.df
```

### Filter data

Use the ImageJ points to select cells in `cdata` which have a point "close enough"
to their centroid.

First, generate a mapping `data.frame`:

```{r}
mapping <- cdata.mp |> filter(has.close.mp) |> 
  select(ucid, closest.mp.id)
```

Lastly, check for unicity:

```{r}
stopifnot(nrow(mapping) == nrow(unique(mapping)))
```

Examine:

```{r}
mapping
```

You can use this information to filter `cdata` by `ucid`:

```{r}
cdata.filtered <- cdata |> 
  filter(ucid %in% mapping$ucid)
```

Done! `cdata.filtered` now contains only cells that were matched to a `0` _Counter_
in ImageJ. Other uses for this include tagging events, or phenotypes of interest.

Optionally use `rcell2.magick` to display some images:

```{r}
cdata.filtered |> 
  rcell2.magick::magickCell(images) |> 
  rcell2.magick::magickForKnitr()
```

## Data analysis

Helping with data analysis is the purpose of the `rcell2` and `rcell2.magick` packages.

Installation instructions for `rcell2` and `rcell2.magick` packages can be found [here](https://github.com/darksideoftheshmoo/rcell2#installing-the-package) and [here](https://github.com/darksideoftheshmoo/rcell2-magick#installing-the-package),
respectively.
