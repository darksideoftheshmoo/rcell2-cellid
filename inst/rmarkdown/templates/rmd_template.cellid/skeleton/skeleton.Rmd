---
title: "rcell2.cellid: CellID Workflow Template"
author: "Nicolás Méndez"
output:
  html_document:
    df_print: paged
    toc: yes
    toc_float:
      collapsed: false
    toc_depth: 4
    number_sections: false
    smooth_scroll: false
    code_folding: show  # hide
    code_download: true
    highlight: breezedark # pygments # tango
    theme: "darkly"
  pdf_document:
    latex_engine: xelatex
    toc: true
    toc_depth: 4
    number_sections: true
editor_options:
  chunk_output_type: inline
date: "`r format(Sys.time(), '%d %B, %Y')`"
urlcolor: blue
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "output/renders") })
# bibliography: references.bib
---

<!-- Download a copy of this file with rcell2.cellid::get_workflow_template_cellid() -->

```{r setup, include=FALSE}
# Set chunk options
knitr::opts_chunk$set(echo = T, message = F, out.width = "100%",
                      # https://stackoverflow.com/a/15081230
                      comment=NA)
                      # https://yihui.org/knitr/options/#chunk-options
                      # https://stackoverflow.com/a/66753995
                      # tidy.opts = list(width.cutoff = 60), tidy = TRUE)
# Remove comments from printed text (https://stackoverflow.com/a/44729363)
# knitr::opts_chunk$set(tidy = TRUE, 
#                       tidy.opts = list(comment = FALSE))


# Set knit options
knitr::opts_knit$set(root.dir = here::here())

library(rcell2.cellid)    # Run CellID entirely in R.
# library(rcell2)         # Load Cell-ID's output
# library(rcell2.magick)  # Filter data using Shiny and preview images with Magick.

library(tidyverse)  # import numpy as np (?)
# library(magick)  # if you need it
```

# Introduction

## Friendly reminder

- **Read the help page** of functions before using them. Open help pages with R's `?` (e.g. `?arguments`).
- **Read the README**.md at rcell2's [GitHub repo](https://github.com/darksideoftheshmoo/rcell2/).

## Minimal example

A minimal usage example with:

* Image filenames in time-course experiment "format": `BF_Position001_time01.tif`
* Default CellID segmentation parameters.
* The built-in CellID binary.

> Note: this is only meant as a quick example, read on to learn more! and use the ?help ;)

### Image directory

First point R to the folder containing the images.

If you already have an appropriate dataset, specify the path like this:

```{r}
# Location of your image set
data.dir <- "/path/to/your/data"
```

Otherwise, install and use the "examples" package.

First, get the example data:

```{r}
if(!requireNamespace("remotes")){
  # Install the "remotes" package if not found:
  install.packages("remotes")
}

if(!requireNamespace("rcell2.examples")){
  # Install the "rcell2.examples" package if not found:
  remotes::install_github("darksideoftheshmoo/rcell2.examples")
}

# List available datasets:
dir(system.file("extdata/sample_datasets/", package = "rcell2.examples"))
```
Second, get the path to the chosen example dataset and check if the files are there:

```{r}
# Example: Choose one set of example images:
data.dir <- system.file("extdata/sample_datasets/sample_time_series/",
                        package = "rcell2.examples")

# List image files in the set:
dir(data.dir)
```

### Prepare arguments for Cell-ID

Optional: use the following if you have images from Metamorph's MDA, you may need to rename them.

```{r eval=F}
# Rename images (uses symlinks by default)
result <- rename_mda(images.path = data.dir)

# Get the path where the renamed images were saved
data.dir <- result$rename.path
```

Optional: customize parameters for CellID (details below).

```{r}
parameters.txt <- rcell2.cellid::parameters_write(rcell2.cellid::parameters_default())
```

Prepare image paths for CellID, with a default "file.pattern":

```{r}
cellid.args <- 
  rcell2.cellid::arguments(path = data.dir,
                           # file.pattern = "^(BF)_Position(\\d+)_time(\\d+).tif$", bf_as_fl = T,  # Settings for a "BF only" experiment.
                           # file.pattern = "^(BF|[A-Z]FP)_Position(\\d+)().tif$"  # Settings for a single frame experiment.
                           # parameters = parameters.txt  # Optional: include if defined previously.
                           )
```

### Preview images

Open your images with FIJI-ImageJ before you begin.

No analysis package exists (yet) that can replace a researcher's visual assesment.

A simple Macro can be run in ImageJ to load virtual hyperstacks of any experiment:

> Note: this macro uses a "file" pattern that only matches input images (and not ".out")
> in a tipically-named set of images.

```{r}
n_axis1 <- length(unique(cellid.args$t.frame))
n_axis2 <- length(unique(cellid.args$pos))
n_axis3 <- length(unique(cellid.args$ch))

# Add 1 to include the BF images as a possible channel
n_axis3 <- n_axis3 + 1

macro <- glue::glue(
  '// Macro',
  'run("Image Sequence...", "open={data.dir} file=(.*\\\\d.tif$) sort use");',
  'run("Stack to Hyperstack...", "order=xyczt(default) channels={n_axis1} slices={n_axis2} frames={n_axis3} display=Grayscale");',
  .sep = "\n"
)

cat(macro)
```

> Note: the dimensions names may be mismatched between R and the macro. This is because 
virtual stacks must be in `xyczt` order (time is likely to end up as the "channels" dimension), 
but the order in which the "Image Sequence..." is loaded depends on how their files are named.

The only restriction of this approach is that only "3" dimensions are available for
browsing: `frame`, `plane`, and `channel`. This is relevant if you wish to browse
segmentation results (which adds another dimension to the set: original vs "out").
A fourth dimension would be needed, but Hyperstacks only provide 3. Alternatively, 
open another virtual hyperstack for the output images, and browse them in-sync.

<!-- Si alguien sabe como reordenar fotos en un stack, que avise. Creo que se puede ¿reslice? ¿algo asi? -->


### Run Cell-ID

Run CellID with the built-in executable:

```{r eval=F}
cell2.out <- 
  rcell2.cellid::cell2(arguments = cellid.args,
                       # progress = T,  # Progress bar (requires doSnow).
                       # cell.command = "~/Software/cellID-linux/cell",  # You may use an external executable.
                       output_coords_to_tsv = T  # Optional! Only works with newer CellID (>= 1.5).
                       )

# Check the output messages:
cell2.out
```

### Load the output

The output tables can be loaded with `cell.load.alt`.

```{r eval=F}
# Load output
cell.data <- rcell2.cellid::cell.load.alt(path = data.dir)
```

<!-- Restore previous output -->
```{r include=F}
# saveRDS(cell.data, file = "inst/extdata/cell.data.RDS")
cell.data <- readRDS(file = "inst/extdata/cell.data.RDS")
```

### Alternatives

Function `load_cell_data` from `rcell2` can load those tables as well.

```{r eval=F}
# rcell2's main analysis package
if(!requireNamespace("rcell2")){
   devtools::install_github("darksideoftheshmoo/rcell2")
}

# Load output
cell_data <- rcell2::load_cell_data(path = data.dir)
```

`rcell2` can also load the cell boundaries and interior pixels coordinates,
if either `output_coords_to_tsv` or `encode_cellID_in_pixels` were set to `TRUE`
when Cell-ID was run.

To load the boundary pixels, use the `cell.load.boundaries`:

```{r eval=F}
# Useful if either "output_coords_to_tsv" or "encode_cellID_in_pixels" were TRUE in cell().
cell.boundaries <- 
  rcell2::cell.load.boundaries(data.source = "masks.tsv",
                               arguments = cellid.args,
                               pixel.type = "b"
                               )
```

<!-- Restore previous output -->
```{r include=F}
# saveRDS(cell.boundaries, file = "inst/extdata/cell.boundaries.RDS")
cell.boundaries <- readRDS(file = "inst/extdata/cell.boundaries.RDS")
```

> This data is only available if `cell2` was run with `output_coords_to_tsv = T`.


### Understanding the data

Access the main output data and plot:

```{r}
cdata <- cell.data$data

cdata %>% ggplot(aes(a.tot, fft.stat)) + 
  geom_point() + facet_grid(~pos)
```

Output variables are described by this documentation function:

```{r}
rcell2.cellid::cellid_output_descriptions(list.output = F)
```

Plot cell boundaries:

> This data is only available if `cell2` has run with `output_coords_to_tsv = T`.

```{r}
cell.boundaries %>% 
  group_by(pos) %>% filter(cellID == 0) %>% 
  filter(pixtype == "b") %>% 
  ggplot(aes(x,y,color=factor(t.frame)))+
  geom_path()+
  facet_wrap(~pos, scales = "free") + theme(aspect.ratio = 1)
```

#### Save and restore progress

We recommend saving the current state at this point.

```{r eval=F}
# Save all variables to a Rdata file.
save.image("01-segmentation_results.Rdata")
```

The workspace image may be restored later on:

```{r eval=F}
# Restore all variables from the Rdata file.
load("01-segmentation_results.Rdata")
```

### Advanced tools

You may want to check out the Shiny/Magick rcell2 analisys package:

```{r eval=F}
# rcell2's image manipulation and cytometry package
if(!requireNamespace("rcell2.magick")){
   devtools::install_github("darksideoftheshmoo/rcell2", ref = "rcell2.magick")
}

# Images data.frame
images <- cell.data$images

# Pics
cdata %>% filter(fft.stat < 0.3, el.p > 0.8) %>% 
  rcell2.magick::magickCell(images)

# Plot
rcell2.magick::cellSpreadPlot(cdata, images)

# App
rcell2.magick::shinyCell(cdata, paths = images)
```

> Images will be displayed by default at RStudio's viewer pane.
> Use `magickForKnitr` and `include_graphics` to include them in this notebook.

# Full usage guide

This section has detailed explanations and usage examples of the tools in `rcell2.cellid`.

## Preprocessing

The following sections may help improve the result of the segmentation,
to catch severe issues early on.

### Image file names

Images are assumed to be in a single directory, and have names with identifiers for:

* Imaging channel (birghtfield, transmission, fluorescence, z-slice, etc.).
* Microscope position (*pos*).
* Time (*t.frame*, optional).

Cell-ID uses the first 3 letters of the file name to group imaging channels.
**This is mandatory**. If your image set does not conform initially, it can be
renamed (or symlinked) using rcell2's `rename_mda`, with custom arguments.

For example, file names for a 2-position time course experiment
are expected to have the following appearance:

```
BF_Position001_time01.tif
BF_Position001_time02.tif
TFP_Position001_time01.tif
TFP_Position001_time02.tif
YFP_Position001_time01.tif
YFP_Position001_time02.tif
BF_Position002_time01.tif
BF_Position002_time02.tif
TFP_Position002_time01.tif
TFP_Position002_time02.tif
YFP_Position002_time01.tif
YFP_Position002_time02.tif
```

The `rcell2` packages rely on regular expressions to gather images and extract 
metadata from their file names (i.e. channel, position, and time frame.)

The file list will be recognized by a specific regular expression (regex).
A regex matching these files can be `^(BF|TFP)_Position(\\d+)_time(\\d+).tif$`;
note that it has **3 capturing groups** (suff between parentheses).
The regex as a whole is used to select images from a directory (filtering out
other files) and the capturing groups are used to extract the metadata.

### Renaming Metamorph MDA images

Metamorph's _Multi-dimensional acquisition_ (MDA for short) may use file 
names different from the usual style (i.e `far6_w2LED-BF--YFPcube--cam_s7_t2.TIF` 
instead of `BF_Position07_time02.tif`, and so on).

The `rename_mda` function renames those files names, making them compatible
with `rcell2`'s defaults. See `?rename_mda` for extra options.

The defaults are useful for a three channel experiment, 
and file names looking like this: `far6_w2LED-BF--YFPcube--cam_s7_t2.TIF`.

A preview of how files will be renamed can be generated:

```{r}
# Choose a sample file name (one or many)
one.filename <- "far6_w2LED-BF--YFPcube--cam_s7_t2.TIF"

# Pass it to rename_mda, setting rename.function to NULL (to avoid actually copying files).
rename_mda(rename.function = NULL, 
           file.names = one.filename) %>% 
  # Get the info we're interested in
  .$status %>% select(file, rename.file)
```

To run the function on all images, provide the path to the images director.

A _dummy_ example follows:

```{r}
# Create a dummy file
dir.create("/tmp/images")
writeLines("", "/tmp/images/far6_w2LED-BF--YFPcube--cam_s7_t2.TIF")

# Rename files
images.path <- "/tmp/images"  # Path to the images produced by MetaMorph's MDA.
rename_mda(images.path)
```

Check output:

```{r}
dir(images.path, recursive = T)
```

The defaults are easily adaptable to other use cases. 
To use the function with different file name patterns, adjust `identifier.pattern`,
`identifier.info`, and `channel.maping.df`. See `?rename_mda` for details.

> Note that the `ch` field in `channel.maping.df` must match exactly the
> text captured by the channel group in the `identifier.pattern` regex.

### Check XY stage coordinates

It may be a good idea to double check that the physical coordinates of your images
match your expectations (i.e. the column/row pairs of each well in a microscopy plate).
This information is stored in TIFF's metadata.

It requires the ijtiff and XML package:

> The xml2 package does not convert the attributes automatically,
> so I stuck to the XML package. See tiff_plane_info's help and source for details.

#### Load TIFF metadata

Get paths to the images:

```{r}
# Choose your own path!
metamorph_pics_dir <- "/path/to/your/data"

# Or use the example images (requires "rcell2.examples", see first example above).
metamorph_pics_dir <- system.file("extdata/sample_datasets/sample_images/",
                                  package = "rcell2.examples")

# List files
dir(metamorph_pics_dir)
```

List plane info for an example image:

```{r}
# Path to a sample image
image_list <- rcell2.cellid::arguments(metamorph_pics_dir, 
                                       file.pattern = "^(BF|[A-Z]FP)_Position(\\d+)().tif$")
metamorph_pics <- paste0(image_list$path, "/", image_list$image)
metamorph_pic <- metamorph_pics[2]
```


```{r}
# Get the image plane metadata
pic_plane_info <- rcell2.cellid::tiff_plane_info(path = metamorph_pic)

pic_plane_info
```

> If the required metadata is not found in the TIFF, a warning will be emitted.
> This can happen if the original images were modified or exported from ImageJ or 
> other sofware. Continue if there are no warnings, or else skip this section.

```{r}
# Show the stage-position properties
subset(pic_plane_info, grepl("stage-position", id))
```

> Our motorized stage works in negative coordinate space, as most CNC machines do.
> Take this into account when plotting.

Get the metadata of all images:

```{r}
plane_info_df <- setNames(metamorph_pics, basename(metamorph_pics)) %>% 
  # Get metadata
  lapply(rcell2.cellid::tiff_plane_info) %>% 
  bind_rows(.id="image") %>% 
  # Fix variable names and types
  mutate(variable = make.names(id)) %>% 
  filter(grepl("stage.position", variable)) %>% 
  mutate(value = as.numeric(value)) %>% 
  # Make it wider
  pivot_wider(id_cols = "image", names_from = "variable", values_from = "value")

plane_info_df
```

Plot XY stage positions:

> This is specially useful when tracing a path for positions in a many-well time-course experiment.

```{r}
ggplot(plane_info_df) +
  geom_point(aes(stage.position.x, stage.position.y))
```

#### Check position indexes

The following code match the images' _position_ (Pos) to their microscope stage _physical_ XY coordinates,
which are stored in the TIFF tags of the original images.

It requires the `images` dataframe in `cell.data` to get the file names,
_but_ you could also use `dir` to get the files by pattern, and `sub` to get the position IDs,
independently of CellID.

```{r}
images <- rcell2.cellid::arguments_to_images(arguments = image_list)
```

Add image metadata and replot the stage's "path":

```{r}
plane_info_df %>% 
  left_join(select(images, image, pos, t.frame, channel)) %>% 
  arrange(pos) %>% 
  ggplot(aes(stage.position.x, stage.position.y, label = pos)) +
  geom_path(aes(group = t.frame)) +
  geom_rect(aes(xmin=stage.position.x-1000, 
                xmax=stage.position.x+1000, 
                ymin=stage.position.y-1000, 
                ymax=stage.position.y+1000,
                group = pos, fill = factor(pos)), alpha =.5)+
  geom_text(size=10) +
  facet_grid(t.frame~channel) + guides(fill = "none") +
  scale_x_reverse() + #coord_fixed()+
  ggtitle("Physical stage coordinates v.s. Position index",
          "Compare the index numbers with the expected physical distrubution in the well plate.\nThe shaded areas around index numbers shuould not overlap with each other.")
```

### Preview images

Open your images with FIJI-ImageJ before you begin.

No analysis package exists (yet) that can replace a researcher's visual assesment.

A simple Macro can be run in ImageJ to load virtual hyperstacks of any experiment.

> Note: this macro uses a "file" pattern that only matches input images (and not ".out")
> in a tipically-named set of images.

```{r}
n_axis1 <- length(unique(cellid.args$t.frame))
n_axis2 <- length(unique(cellid.args$pos))
n_axis3 <- length(unique(cellid.args$ch))

# Add 1 to include the BF images as a possible channel
n_axis3 <- n_axis3 + 1

macro <- glue::glue(
  '// Macro',
  'run("Image Sequence...", "open={data.dir} file=(.*\\\\d.tif$) sort use");',
  'run("Stack to Hyperstack...", "order=xyczt(default) channels={n_axis1} slices={n_axis2} frames={n_axis3} display=Grayscale");',
  .sep = "\n"
)

cat(macro)
```

> Note: the dimensions names may be mismatched between R and the macro. This is because 
virtual stacks must be in `xyczt` order (time is likely to end up as the "channels" dimension), 
but the order in which the "Image Sequence..." is loaded depends on how their files are named.

The only restriction of this approach is that only "3" dimensions are available for
browsing: `frame`, `plane`, and `channel`. This is relevant if you wish to browse
segmentation results (which adds another dimension to the set: original vs "out").
A fourth dimension would be needed, but Hyperstacks only provide 3. Alternatively, 
open another virtual hyperstack for the output images, and browse them in-sync.

<!-- Si alguien sabe como reordenar fotos en un stack, que avise. Creo que se puede ¿reslice? ¿algo asi? -->

### FFT filter on BF images

#### Sequential

Optionally, use ImageJ's bandpass FFT filter on the defocused brightfield images.

Here is a wrapper that does most of this for you, calling ImageJ headlessly.

Prepare new image directory with the subset of BF files:

```{r eval=F}
# Choose your own path!
data.dir <- "/path/to/your/data"

# Or use the example images (requires "rcell2.examples", see first example above).
data.dir <- system.file("extdata/sample_datasets/sample_time_series/",
                        package = "rcell2.examples")

# List files
dir(data.dir)
```


```{r eval=F}
# Get image paths
cellid.args <- 
  rcell2.cellid::arguments(path = data.dir,
                           file.pattern = "^(BF|[TRY]FP)_Position(\\d+)_time(\\d+).tif$") %>% 
  filter(pos %in% good.pos)

# Save BF files
bf.files <- cellid.args %>%
  select(bf, path) %>% with(paste0(path,"/",bf)) %>% unique()

# Make a directory to put them in
fft.bfs.subdirectory <- "bf_subset"
fft.bfs.dir <- paste0(new.data.dir, "/", fft.bfs.subdirectory)
dir.create(fft.bfs.dir)

# Link them over
file.symlink(from = normalizePath(bf.files),
             to = paste0(dirname(bf.files[1]), "/", fft.bfs.subdirectory, "/", basename(bf.files)))
```

Run FFT filter:

```{r eval=F}
# This may take a while...
imagej_fft_filter(pic.path = fft.bfs.dir)
```

Symlink the rest of the images (fluorescence imgs) to the filtered directory:

```{r eval=F}
# Get all files
all.files <- cellid.args %>% 
  with(paste0(path[1],"/", c(bf, image))) %>% unique()
# And the difference with the BF vector
the.rest <- setdiff(all.files, bf.files)
# Symlink over to the directory of the FFT-filtered BFs
if(length(all.files) == length(bf.files) + length(the.rest)){
  file.symlink(from = normalizePath(the.rest),
               to = paste0(dirname(the.rest[1]), "/bf_subset/filtered/", basename(the.rest)))
}
```


#### Parallel

```{r eval=F}
# Get image paths
cellid.args <-
  rcell2.cellid::arguments(path = new.data.dir,
                           file.pattern = "^(BF|[TRY]FP)_Position(\\d+)_time(\\d+).tif$") %>% 
  filter(pos %in% positions)
```

Split the BF files by position, and symlink them to different subdirectories:

```{r eval=F}
cellid.args.split <- split(cellid.args, ~pos)

fft.bfs.subdirs <- list()

for(i in seq_along(cellid.args.split)) {
  # Save BF files
  bf.files <- cellid.args.split[[i]] %>%
    select(bf, path) %>% with(paste0(path,"/",bf)) %>% unique()
  
  # Make a directory to put them in
  fft.bfs.subdirectory <- paste0("bf_subset_", i)
  fft.bfs.dir <- paste0(new.data.dir, "/", fft.bfs.subdirectory)
  dir.create(fft.bfs.dir)
  
  # Link them over
  file.symlink(from = normalizePath(bf.files),
               to = paste0(dirname(bf.files[1]), "/", fft.bfs.subdirectory, "/", basename(bf.files)))
  
  fft.bfs.subdirs[i] <- fft.bfs.dir
}

fft.bfs.subdirs
```

Run FFT filter in parallel, with one thread per subdirectory:

```{r eval=F}
n_cores <- parallel::detectCores() #- 1
n_chunks <- length(fft.bfs.subdirs)

# Make cluster
cl <- parallel::makeCluster(
  spec = min(n_chunks,n_cores), 
  setup_strategy = "sequential"  #https://github.com/rstudio/rstudio/issues/6692
)

# This may take a while...
doParallel::registerDoParallel(cl)
foreach(fft.bfs.subdir=fft.bfs.subdirs, .packages = "rcell2.cellid") %dopar% {
  imagej_fft_filter(pic.path = fft.bfs.subdir, imagej.path="~/Software/FIJI/Fiji.app/ImageJ-linux64")
}
parallel::stopCluster(cl)
```

Symlink filtered BFs in each sibdirectory to a single "filtered" images directory:

```{r eval=F}
filtered.bfs <- dir(paste0(fft.bfs.subdirs, "/filtered"), full.names = T)

filtered.bfs.dir <- paste0(new.data.dir, "/fft_images_dataset/")
dir.create(filtered.bfs.dir)

result <- file.symlink(from = normalizePath(filtered.bfs), 
                       to = paste0(filtered.bfs.dir, basename(filtered.bfs)))

all(result)  # Check
```

Symlink the rest of the images (fluorescence imgs) to the filtered directory:

```{r eval=F}
# Get all files
fl.files <- cellid.args %>% 
  with(paste0(path, "/", image)) %>% unique()

# Symlink over to the directory of the FFT-filtered BFs
result <- file.symlink(from = normalizePath(fl.files),
                       to = paste0(filtered.bfs.dir, basename(fl.files)))

all(result)  # Check
```

> Done!

You can run CellID using this directory as a data.dir:

```{r eval=F}
normalizePath(filtered.bfs.dir)
```

## Segmentation

In this section we will prepare and run Cell-ID.

### Parameters

First we must configure the Cell-ID parameters that affect cell segmentation, 
tracking, and some corrections.

#### Descriptions

Description for parameters:

```{r}
rcell2.cellid::cellid_parameter_descriptions(list_format = F)
```

#### Example parameters

There is a helper function to prepare parameters more easily:

```{r}
parameters.list <- 
  rcell2.cellid::parameters_default(background_reject_factor = 0.8)

parameters.list$max_split_over_minor
```

Parameters must be written to a `parameters.txt` plain text file with the proper syntax,
which Cell-ID will read later on.

For this purpose, you may use the `parameters_write()` function. It writes the parameters,
and returns the path where it was saved.

<!-- to do: consider moving this step into cell2() -->

```{r}
parameters.txt <- rcell2.cellid::parameters_write(parameters.list)

parameters.txt
```

Este path es el que hay que pasarle a `arguments()` en la siguiente sección.

Revisemos el contenido del `parameters.txt` que generamos recién:

```{r}
writeLines(readLines(parameters.txt))
```

Here is a valid, hand-made parameter list, with the same defaults:

```{r eval=F}
parameters.list <- list(
  max_split_over_minor = 0.50,
  max_dist_over_waist = 8.00,
  max_pixels_per_cell = 2000,
  min_pixels_per_cell = 75,
  background_reject_factor = 0.75,
  tracking_comparison = 0.20,
  align_individual_cells = F,
  align_fl_to_bf = T,
  image_type = "brightfield",
  bf_fl_mapping = "list"
  )
```

### Images and Arguments

Define the path of the original images:

```{r}
# Choose your own path!
data.dir <- "/path/to/your/data"

# Or use the example images (requires "rcell2.examples", see first example above).
data.dir <- system.file("extdata/sample_datasets/sample_time_series/",
                        package = "rcell2.examples")

# List files
dir(data.dir)
```

The `arguments` function outputs a data.frame with information from images, 
which is needed to run Cell-ID.

The key parameter is `file.pattern`, a regular expression used to find image
files in the `data.dir` path.

By default, `arguments` uses:

    "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$"

Enclosed in parentheses are the "capture groups" of the regular expression.
These delimit the parts of the file name which contain identifiers for 

1. Imaging channel.
2. Stage position index.
3. Time-frame index.

If your experiment has a single time frame, and it is not part of the file names,
the content of the corresponding capturing group can be deleted (leaving the
empty parentesis in place):

    "^(BF|[A-Z]FP)_Position(\\d+)().tif$"

The regular expression can be used to select or filter out sets of images (
though it will be often easier to use R's tool for this). To select only position
with index "2", and times 2, 3 and 4, use:

    "^(BF|[A-Z]FP)_Position(0*2)_time(0*[423]).tif$"

> Note the `0*` in front of numbers. This indicates that there might me be leading
> zeros in front of the position and time identifiers.

#### Input file pattern

Adjust file patterns in `rcell2.cellid::arguments`. Go through the function help
page to learn about their parameters.

> **Important**: the patterns used in `arguments` must match the ones used in
> `cell.load.alt` when loading Cell-ID's output (later on).

Original images file pattern examples; choose one and comment the others:

```{r}
# Default value: all channels, no z-stack.
arguments.file.pattern <- "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$"

# To consider z-stacks:
# arguments.file.pattern <- "^(BF|[A-Z]\d+)_Position(\d+)_time(\d+).tif$"

# BF or TFP only, no t.frame info.
# arguments.file.pattern <- "^(BF|TFP)_Position(\\d+)().tif$"
```

#### Example

Check that image file names are properly recognized:

```{r}
cellid.args <- rcell2.cellid::arguments(data.dir,
                                        file.pattern = arguments.file.pattern,
                                        parameters = parameters.txt)  # Parameters are specified here.

cellid.args
```

Yo may filter out or select certain image sets at this stage:

```{r}
cellid.args %>% filter(pos == 2, t.frame %in% c(4,2,3))
```

### Run Cell-ID

The `cell2` function generates system commands to run Cell-ID,
and executes them in parallel by default.
<!-- La función `cell2` genera comandos para llamar a CellID por línea de comandos y los ejecuta en paralelo. -->

The `cell.command` argument must be the path to the Cell-ID binary executable.
In this version of `rcell2`, it defaults to `NULL`, and the intenal executable 
is used.
<!-- El parámetro `cell.command` es el path al ejecutable. En esta versión de `rcell2.cellid`, -->
<!-- el binario se compila durante la instalación y se usa por defecto. -->

```{r eval=F}
cell2.result <- rcell2.cellid::cell2(arguments = cellid.args,
                                     # dry = T,
                                     n_cores = 2)
```

> `n_cores` can be set to the number of CPU cores you want to use to parallelize
> the segmentation (relying on `foreach`). It defaults to use all but one of the
> available cores.

> If `dry = T` is set, the input will be processed but Cell-ID will not be run.
> This may be useful to do a final check on the commands that would have been run,
> before actually running the segmentation.
<!-- La opción `dry = T` indica a la función hacer "todo" menos ejecutar CellID, e imprime los comandos que habría usado. -->
> The commands in the output can also be run mannualy from a terminal, which
> can be useful for debugging.
<!-- Para correr los comandos, usen `dry = F` (aunque tambien pueden copiarlos y pegarlos en una terminal, si están en Linux o Mac OS). -->

### Output data

Cell-ID's output consists mainly of:

* Segmented images (named with the `.out.tif` posfix).
  * *Optional:* "BF.out" with identified binary masks.
* Tables with single-cell quantitative information (from their morphology and fluorescence).
  * *Optional:* Tables with the boundary and interior pixels of identified cell.

#### Output file pattern

File patterns for the image set may vary slightly; depending on what images were 
provided as input, and the identifiers in their file names.

The most common fluorescent channel pattern for `cell.load.alt` and `parameter_scan`
are defined below. Choose one pattern and comment the others:

```{r}
# Default value: all fluorescent tags, including Z-stack fluorescence channels.
fluorescence.pattern <- "^([GCYRT]FP|[GCYRT]\\d+)_Position\\d+_time\\d+.tif$"

# Default: add "BF" as a possible channel (when CellID was run with bf_as_fl=TRUE)
# fluorescence.pattern <- "^([GCYRT]FP|[GCYRT]\\d+|BF)_Position\\d+_time\\d+.tif$"

# Same as defualt, but without t.frame information.
# fluorescence.pattern <- "^([GCYRT]FP|[GCYRT]\\d+)_Position\\d+.tif$"
```

#### Load the output

The output tables can be loaded with `cell.load.alt`.

```{r eval=F}
# Load output
cell.data <- rcell2.cellid::cell.load.alt(path = data.dir,
                                          fluorescence.pattern=fluorescence.pattern)
```

> Note: your `fluorescence.pattern` regex may vary (read the previous section).

Alternatively, function `load_cell_data` from `rcell2` can load those tables as well.

```{r eval=F}
# rcell2's main analysis package
if(!requireNamespace("rcell2")){
   devtools::install_github("darksideoftheshmoo/rcell2")
}

# Load output
cell_data <- rcell2::load_cell_data(path = data.dir)
```

`rcell2` can also load the cell boundaries and interior pixels coordinates,
if either `output_coords_to_tsv` or `encode_cellID_in_pixels` were set to `TRUE`
when Cell-ID was run.

To load the boundary pixels, use the `cell.load.boundaries`:

```{r eval=F}
# Useful if either "output_coords_to_tsv" or "encode_cellID_in_pixels" were TRUE in cell().
cell.boundaries <- 
  rcell2::cell.load.boundaries(data.source = "masks.tsv",
                               arguments = cellid.args,
                               pixel.type = "b"
                               )
```

<!-- Restore previous output -->
```{r eval=F}
# Load output
cell.data <- rcell2.cellid::cell.load.alt(path = data.dir)
```

> This data is only available if `cell2` was run with `output_coords_to_tsv = T`.

#### Variable descriptions

To help understand CellID's output, we documented the descriptions of variables
in `cell.data$data`. They are available through a function:

```{r}
rcell2.cellid::cellid_output_descriptions(list.output = F)
```

### Tuning parameters

Sometimes we want to test out many parameter combinations 
before running Cell-ID in the full dataset.

This functionality requires the `magick` R package,
and ImageMagick on your system (which can be obtained 
[here](https://imagemagick.org/script/download.php)). 

Run the following to install the R package if absent:

```{r}
if(!requireNamespace("magick")){
  install.packages("magick")
}
```

#### Example setup

Define working paths for parameter testing:

* One with the images.
* Another one for testing.

```{r}
# The output of the parameter scan will be saved here:
test.dir <- "/tmp/images_directory/test.dir"

# Or use the example images
data.dir <- system.file("extdata/sample_datasets/sample_time_series/",
                        package = "rcell2.examples")
```

Setup arguments and patterns as usual (if not done already):

```{r}
# Default value: all channels, no z-stack.
arguments.file.pattern <- "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$"

# Get full image list
cellid.args <- rcell2.cellid::arguments(data.dir,
                                        file.pattern = arguments.file.pattern)
```

#### Image set

Choose which image sets in `cellid.args` you wish to use for the parameter scan.

For example, choose some *positions* (image sets) and *t.frame*s (time frames)
to restrict the image test set to only some of them.

```{r}
test.pos = unique(cellid.args$pos)
test.frames = unique(cellid.args$t.frame)

# Filter cellid.args to choose image sets for the scan
scan.arguments <-  
  subset(cellid.args, 
         pos %in% test.pos & t.frame %in% test.frames)

scan.arguments
```

#### Parameter combinations

For each parameter variation, we need a new parameters file.

In this example, only `background_reject_factor` is scanned:

```{r}
parameters.list <- rcell2.cellid::parameters_default(
  background_reject_factor = seq(from=0, to=1.5, by = 0.4)
)

parameters.list$background_reject_factor
```

The list must now be expanded into a data.frame:

```{r}
parameters.df <- expand.grid(parameters.list)

parameters.df
```

> Note: You might want to select some rows from that table. In that case, simply filter it.

#### Automatic scan

> Now comes the magic part.
> This script uses temporary directories to work on, 
> and avoids messing up the main data directory, 
> while running CellID in parallel for each parameter variation.

Just run:

```{r eval=F}
scan.results <- 
  parameter_scan(parameters.df = parameters.df,
                 scan.arguments = scan.arguments, 
                 test.dir = test.dir)
```

> Have a look at the function's source code if you like, its hopefully well commented.

<!-- Restore previous output -->
```{r include=F}
# saveRDS(scan.results, file = "inst/extdata/scan.results.RDS")
scan.results <- readRDS(file = "inst/extdata/scan.results.RDS")
```

#### Plot summary

A few "summary" quantities are calculated for each run:

* `fft`
* `el.p`
* `ucids`
* `persistence`
* `roughness`
* `roughness2`

The average of these quantities may be useful for selecting optimal parameters.

A few of combinations these are plotted below.

First get the output dataframe:

```{r}
results.bound <- scan.results$results.bound
```

Plot:

```{r}
results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(persistence, el.p/fft, label = id,
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. frames per cell (persistence) VS 'el.p/fft' per parameter variation") +
  theme_minimal() + scale_color_discrete()

results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(persistence, el.p/fft, label = id,
                 color = as.ordered(max_split_over_minor)),
             alpha = .7, fill = "NA") +
  ggtitle("Avg. frames per cell (persistence) VS 'el.p/fft' per parameter variation") +
  theme_minimal() + scale_color_discrete()
```

Plot:

```{r}
results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(el.p, fft, label = id,
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. el.p VS Avg. fft.stat per parameter variation") +
  theme_minimal() + scale_color_discrete()

results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(roughness, persistence, label = paste0(id, "=", background_reject_factor),
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. roughness per cell VS Avg. frames per cell (persistence) per parameter variation") +
  theme_minimal() + scale_color_discrete()

results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(roughness2, persistence, label = paste0(id, "=", background_reject_factor),
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. roughness2 per cell VS Avg. frames per cell (persistence) per parameter variation") +
  theme_minimal() + scale_color_discrete()
```


#### Review result in ImageJ

Make TIFF stacks for a particular channel.

The stacks are annotated with the parameters used for each segmentation, and other metadata (position, time frame, and channel).

A copy-paste-ready ImageJ Macro will be printed out, to easily load them as virtual Hyperstacks in ImageJ.

```{r eval=F}
stack.paths <- 
  make_scan_stacks(scan.results = scan.results, 
                   stack.channels = "BF.out")
```

<!-- Restore previous output -->
```{r include=F}
# saveRDS(stack.paths, file = "inst/extdata/stack.paths.RDS")
stack.paths <- readRDS(file = "inst/extdata/stack.paths.RDS")
```

> Have a look at the function's source code if you like, its hopefully well commented.

Now copy paste the macro to a new macro window in ImageJ, and hit run! The stack should be loaded automagically.

Paths and macros are saved in the output:

```{r}
names(stack.paths)
```

```{r}
stack.paths$imagej.macros
```

```{r}
stack.paths$stack.paths
```

#### Final parameter set

This parameter set was chosen for FFT-filtered BFs.

Under 0.8 background_reject_factor, there were some "persisten" _ghosts_;
elongated _chorizos_ on the sides of cells.

```{r eval=F}
parameters.list <- rcell2.cellid::parameters_default(
  background_reject_factor = 0.8,
  max_split_over_minor = 0.6,
  max_dist_over_waist = 6,
  max_pixels_per_cell = 3500,
  treat_brightfield_as_fluorescence_also = T
)
```

<!-- TODO: nombrar los stacks por parameter modificado -->

## Data analysis

Helping with data analysis is `rcell2`'s purpose.

Installation instructions for `rcell2` and `rcell2.magick` packages can be found [here](https://github.com/darksideoftheshmoo/rcell2#installing-the-package) and [here](https://github.com/darksideoftheshmoo/rcell2-magick#installing-the-package),
respectively.
