---
title: "rcell2.cellid: CellID Workflow Template"
author: "Nicolás Méndez"
output:
  html_document:
    df_print: paged
    toc: yes
    toc_float:
      collapsed: false
    toc_depth: 4
    number_sections: false
    smooth_scroll: false
    code_folding: show  # hide
    code_download: true
    highlight: breezedark # pygments # tango
    theme: "darkly"
  pdf_document:
    latex_engine: xelatex
    toc: true
    toc_depth: 4
    number_sections: true
editor_options:
  chunk_output_type: inline
date: "`r format(Sys.time(), '%d %B, %Y')`"
urlcolor: blue
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "output/renders") })
# bibliography: references.bib
---

<!-- Download a copy of this file with rcell2.cellid::get_workflow_template_cellid() -->

```{r setup, include=FALSE}
# Set chunk options
knitr::opts_chunk$set(echo = T, message = F, out.width = "100%", eval = F,
                      # https://stackoverflow.com/a/15081230
                      comment=NA)
                      # https://yihui.org/knitr/options/#chunk-options
                      # https://stackoverflow.com/a/66753995
                      # tidy.opts = list(width.cutoff = 60), tidy = TRUE)
# Remove comments from printed text (https://stackoverflow.com/a/44729363)
# knitr::opts_chunk$set(tidy = TRUE, 
#                       tidy.opts = list(comment = FALSE))


# Set knit options
knitr::opts_knit$set(root.dir = here::here())

library(rcell2.cellid)    # Run CellID entirely in R.
# library(rcell2)         # Load Cell-ID's output
# library(rcell2.magick)  # Filter data using Shiny and preview images with Magick.

library(tidyverse)  # import numpy as np (?)
# library(magick)  # if you need it
```

# Introduction

This notebook contains a minimal [Example workflow], with a broad overview of the pipeline,
and a [Full usage guide] with in-depth explanations and advanced usage examples.

## Friendly reminder

- **Read this notebook carefully**.
- Use the **help page** of functions before using them. Open help pages with R's `?` (e.g. `?arguments`).
- Read the README.md at rcell2's [GitHub repo](https://github.com/darksideoftheshmoo/rcell2/).

## Example workflow

This is only meant as a quick example.

For full usage details, skip to the [Full usage guide] section of this notebook, 
and read it carefully.

Always read the `?help` before using a function ;) specially when they do file operations,
which are irreversible.

This example uses:

* Image examples from the `rcell2.examples` package.
* Images and filenames in time-course experiment "format": `BF_Position001_time01.tif`
* Default CellID segmentation parameters.
* The built-in CellID binary.

### Images directory

First point R to the folder containing the images. This notebook obeys the path
specified in the `data.dir` variable. Make sure to assign its value once, or 
double-check before overwriting it.

In this example we install and use a set from the "examples" package. A more
detailed explanation is available in the [Path to the dataset] section of
this notebook.

```{r}
if(!requireNamespace("remotes")){
  # Install the "remotes" package if not found:
  install.packages("remotes")
}

if(!requireNamespace("rcell2.examples")){
  # Install the "rcell2.examples" package if not found:
  remotes::install_github("darksideoftheshmoo/rcell2.examples")
}

# Example: Choose one set of example images:
data.dir <- system.file("extdata/sample_datasets/sample_time_series/",
                        package = "rcell2.examples")
# List image files in the set:
dir(data.dir)
```

### Naming images for Cell-ID

Images output by the acquisition software may result in file
names different from the default style (i.e `YFP_Position01_time1.tif`, and so on).
The default pattern is described at the [Image file names] section of this notebook.

The `rename_mda` function will help you rename file names to match that pattern.
The function is provided by the `rcell2.cellid` package. A full example on how to
use it is available below, in the [Renaming images] section of this notebook.

### Run Cell-ID

1. Customize parameters for CellID.

```{r}
# Create a list of parameters with default values.
parameters.list <- rcell2.cellid::parameters_default()

# Write the parameters to a plain-text file, and save its path.
parameters.txt <- rcell2.cellid::parameters_write(parameters.list)
```

> Note: segmentation parameters for Cell-ID and criteria to customize them
> are discussed in the [Parameters] section of this notebook.

2. Prepare the "arguments" dataframe for CellID, which lists the image files that match
   the regular expression specified in `file.pattern`.

```{r}
# Gather images
cellid.args <- 
  rcell2.cellid::arguments(path = data.dir, 
                           parameters = parameters.txt)
```

> Note: the default file pattern will match file names that match de default pattern
> (described in the [Image file names] section). Alternative patterns are discussed
> in the [Arguments] section.

3. Run Cell-ID with the built-in executable:

```{r eval=F}
cell2.out <- 
  rcell2.cellid::cell2(arguments = cellid.args,
                       # progress = T,  # Progress bar (requires doSnow).
                       # cell.command = "~/Software/cellID-linux/cell",  # You may use an external executable.
                       output_coords_to_tsv = T  # Optional! Only works with newer CellID (>= 1.5).
                       )

# Check the output messages:
cell2.out
```

> Note: we suggest that you check your images before segmentation, as shown in the
> [Preview images in ImageJ] section. It may be critical to optimize parameters on a subset of 
> images, before processing the whole experiment, as shown in the [Tuning parameters] 
> section.

### Load the output

The output tables can be loaded with `cell.load.alt` provided by this package.

```{r eval=F}
# Load output
cell.data <- cell.load.alt(path = data.dir)
```

> Note: detailed usage of this function is described at the [Output data] section of this
> notebook.

`rcell2.cellid` can also load the cell boundaries and interior pixels coordinates,
if either `output_coords_to_tsv` or `encode_cellID_in_pixels` were set to `TRUE`
when Cell-ID was run.

To load the boundary pixels, use the `cell.load.boundaries`:

```{r eval=F}
# Useful if either "output_coords_to_tsv" or "encode_cellID_in_pixels" were TRUE in cell().
cell.boundaries <- 
  cell.load.boundaries(data.source = "masks.tsv",
                       positions = cell.data$positions,
                       pixel.type = "b")
```

> This data is only available if `cell2` was run with `output_coords_to_tsv = T`.

> Note: `rcell2` provides the `load_cell_data` and `cell.load.boundaries` functions,
> to load the measurements and cell boundary pixels, respectively.

### Understanding the data

Access the main output data and plot:

```{r}
cdata <- cell.data$data

cdata %>% ggplot(aes(a.tot, fft.stat)) + 
  geom_point() + facet_grid(t.frame~pos)
```

> Note: the "c" in "cdata" stands for _cell_ data.

Output variables are described by this documentation function:

```{r}
rcell2.cellid::cellid_output_descriptions(list.output = F)
```

Plot cell boundaries:

```{r}
cell.boundaries %>% 
  group_by(pos) %>% filter(cellID == 0) %>% 
  filter(pixtype == "b") %>% 
  ggplot(aes(x,y,color=factor(t.frame)))+
  geom_path()+
  facet_wrap(~pos, scales = "free") + theme(aspect.ratio = 1)
```

> This data is only available if `cell2` has been run with `output_coords_to_tsv = T`.

### Load position metadata

This step is optional, but also part of our usual workflow.

The `pdata` CSV file holds information about how the cells
of each position (and time) were prepared and treated.

Get the path to the file:

```{r}
# pdata_path <- "path/to/your/pdata.csv"
pdata_path <- dir(data.dir, "pdata.csv", full.names = T)  # Sample pdata

pdata_path
```

Load "pdata":

```{r}
# It is a "metadata" dataframe we usually join to cdata by "position" and/or "t.frame",
# which contains other experimental variables: simuli concentrations, notes, etc.
pdata <- readr::read_csv(pdata_path)

pdata
```

> Note: the "p" in "pdata" stands for microscope _position_ data.

This table is usually joined to cdata by position (and time frame if available).

> Warning: `load_cell_data` does the following automatically if a pdata.csv file is found next to the images.
> If it were the case, you shouldn't run the join again.

```{r eval=F}
cdata <- left_join(cdata, pdata)
```

### Save and restore progress

We recommend saving the current state at this point.

```{r eval=F}
# Save all variables to a Rdata file.
save.image("01-segmentation_results.Rdata")
```

The workspace image may be restored later on:

```{r eval=F}
# Restore all variables from the Rdata file.
load("01-segmentation_results.Rdata")
```

### Advanced tools

You may want to check out the Shiny/Magick rcell2 analisys package!

It provides functions to manipulate images of single cells into strips, mosaics,
and plots. It has it's own notebook with full examples and explanations.

Execute the following to install the package.

```{r eval=F}
if(!requireNamespace("rcell2.magick")) remotes::install_github("darksideoftheshmoo/rcell2-magick")
```

Run the following to open package's notebook:

```{r}
rcell2.magick::get_workflow_template_magick()
```

Alternatively, run the following line-by-line, to preview its features.

```{r eval=F}
# Images data.frame
images <- cell.data$images

# Pics
cdata %>% filter(fft.stat < 0.3, el.p > 0.8) %>% 
  rcell2.magick::magickCell(images)

# Plot
rcell2.magick::cellSpreadPlot(cdata, images)

# App
rcell2.magick::shinyCell(cdata, paths = images)
```

# Full usage guide

This section has detailed explanations and usage examples of the tools in `rcell2.cellid`.

## Path to the dataset

First point R to the folder containing the images. This notebook obeys the path
specified in the `data.dir` variable. Make sure to assign its value once, or 
double-check before overwriting it.

If you already have an appropriate dataset, specify the path to the images like this:

> Note: the aprropriate pattern for file names is described at the [Image file names]
> section of this notebook.

```{r}
# Location of your image set
data.dir <- "/path/to/your/data"

# R has an interactive file chooser
data.dir <- dirname(file.choose())
```

Otherwise, install and use the "examples" package.

First, get the example data:

```{r}
if(!requireNamespace("remotes")){
  # Install the "remotes" package if not found:
  install.packages("remotes")
}

if(!requireNamespace("rcell2.examples")){
  # Install the "rcell2.examples" package if not found:
  remotes::install_github("darksideoftheshmoo/rcell2.examples")
}

# List available datasets:
dir(system.file("extdata/sample_datasets/", package = "rcell2.examples"))
```

Second, get the path to the chosen example dataset and check if the files are there:

> The dataset selected in the chunk below is a subset of a larger experiment.
> The subset contains two positions (4, 12), three time frames (10, 20, 30),
> three 'fluorescence' channels (TFP, YFP), and the mandatory BF channel.

```{r}
# Example: Choose one set of example images:
data.dir <- system.file("extdata/sample_datasets/sample_time_series/",
                        package = "rcell2.examples")
```

> In the chunk above we set up `data.dir` to hold the path to samples images of a
time-course experiment. This will replace any previous value!

Finally, check if the files are there:

```{r}
# List image files in the set:
dir(data.dir)
```

## Image file names

Images are assumed to be in a single directory, and have names with identifiers for:

* Imaging channel (bright field, transmission, fluorescence, z-slice, etc.).
* Microscope position (*pos*).
* Time (*t.frame*, optional).

Cell-ID uses the first 3 letters of the file name to group imaging channels.
**This is mandatory**. If your image set does not conform initially, it can be
renamed (or symlinked) using rcell2's `rename_mda`, with custom arguments.

For example, file names for a 2-position time course experiment
are expected to have the following appearance:

```
BF_Position001_time01.tif
BF_Position001_time02.tif
TFP_Position001_time01.tif
TFP_Position001_time02.tif
YFP_Position001_time01.tif
YFP_Position001_time02.tif
BF_Position002_time01.tif
BF_Position002_time02.tif
TFP_Position002_time01.tif
TFP_Position002_time02.tif
YFP_Position002_time01.tif
YFP_Position002_time02.tif
```

The `rcell2` packages rely on regular expressions to gather images and extract 
metadata from their file names (i.e. channel, position, and time frame.)

The file list will be recognized by a specific regular expression (regex).
A regex matching these files can be `^(BF|TFP)_Position(\\d+)_time(\\d+).tif$`;
note that it has **3 capturing groups** (suff between parentheses).
The regex as a whole is used to select images from a directory (filtering out
other files) and the capturing groups are used to extract the metadata.

### Renaming images

Metamorph's _Multi-dimensional acquisition_ (MDA for short) may use file 
names different from the usual style (i.e `far6_w2LED-BF--YFPcube--cam_s7_t2.TIF` 
instead of `BF_Position07_time02.tif`, and so on).

The `rename_mda` function renames those files names, making them compatible
with `rcell2`'s defaults. See `?rename_mda` for extra options.

The defaults are useful for a three channel experiment, 
and file names looking like this: `far6_w2LED-BF--YFPcube--cam_s7_t2.TIF`.

A preview of how files will be renamed can be generated:

```{r}
# Choose a sample file name (one or many)
one.filename <- "far6_w2LED-BF--YFPcube--cam_s7_t2.TIF"

# Pass it to rename_mda, setting rename.function to NULL (to avoid actually copying files).
rename_mda(rename.function = NULL, 
           file.names = one.filename) %>% 
  # Get the info we're interested in
  .$status %>% select(file, rename.file)
```

A "renaming data frame" (`images.info` below) can be extracted and examined before renaming all images:

```{r}
# Set rename.function to NULL (to avoid actually copying files).
images.info <- 
  rename_mda(rename.function = NULL, 
             rename.dataframe = TRUE,
             file.names = one.filename)

images.info
```

The updated `images.info` data frame can also be adjusted and then used to rename images:

```{r}
# Example: adjust "t.frame".
images.info <- images.info |> mutate(t.frame = 99)

# Pass the updated data.frame to the "rename.dataframe" argument.
# Set rename.function to NULL (to avoid actually copying files for now).
images.info.final <- 
  rename_mda(rename.function = NULL, 
             rename.dataframe = images.info,
             file.names = one.filename)

images.info.final
```

To run the function on all images, provide the path to the images directory.

A _dummy_ example follows:

```{r}
# Path to the images produced by MetaMorph's MDA.
images.path <- "/tmp/images/"  
# Create a temporary directory
dir.create(images.path)
# Create a dummy file
writeLines(text = "dummy content", 
           con = paste0(images.path, "far6_w2LED-BF--YFPcube--cam_s7_t2.TIF"))

# Rename files
rename_mda(images.path)
```

List all files in the images directory to inspect the result:

```{r}
dir(images.path, recursive = T)
```

The defaults are easily adaptable to other use cases. 
To use the function with different file name patterns, adjust `identifier.pattern`,
`identifier.info`, and `channel.maping.df`. See `?rename_mda` for details.

> Note that the `ch` field in `channel.maping.df` must match exactly the
> text captured by the channel group in the `identifier.pattern` regex.
> Read the function's help page for details: `?rename_mda`.

## Preprocessing

The following sections may help improve the result of the segmentation,
to catch severe issues early on.

### Check that all images are there

The arguments function will run several tests (using `arguments_check` internally)
before returning the list of images for cell-ID.

Warnings (or errors if desired) will be generated if the checks fail.

```{r}
# Get images and their metadata.
image_list <- rcell2.cellid::arguments(paste0(data.dir, "/renamed"), 
                                       check_fail = TRUE,
                                       file.pattern = "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$")
```

### Check XY stage coordinates

It may be a good idea to double check that the physical coordinates of your images
match your expectations (i.e. the column/row pairs of each well in a microscopy plate).
This information is stored in TIFF's metadata.

It requires the `ijtiff` and `XML` packages, install them by running the following:

```{r}
if(!requireNamespace("ijtiff")) install.packages("ijtiff")
if(!requireNamespace("XML")) install.packages("XML")
```

<!-- Internal note: The xml2 package does not convert the attributes automatically, 
so I stuck to the XML package. See tiff_plane_info's help and source for details. -->

#### Load TIFF metadata

Get paths to the images:

```{r}
# Choose your own path!
metamorph_pics_dir <- "/path/to/your/data"

# Or use the example images (requires "rcell2.examples", see first example above).
metamorph_pics_dir <- system.file("extdata/sample_datasets/sample_images/",
                                  package = "rcell2.examples")

# List files
dir(metamorph_pics_dir)
```

Get the path to an example image:

```{r}
# Path to a sample image
image_list <- rcell2.cellid::arguments(metamorph_pics_dir, 
                                       file.pattern = "^(BF|[A-Z]FP)_Position(\\d+)().tif$")
metamorph_pics <- paste0(image_list$path, "/", image_list$image)
metamorph_pic <- metamorph_pics[2]
```

> Note: the usage of the "file.pattern" argument is explained below, at the
> [Arguments] section of this notebook.

List plane info for the image:

```{r}
# Get the image plane metadata
pic_plane_info <- rcell2.cellid::tiff_plane_info(path = metamorph_pic)

pic_plane_info
```

> If the required metadata is not found in the TIFF, a warning will be emitted.
> This can happen if the original images were modified or exported from ImageJ or 
> other sofware. Continue if there are no warnings, or else skip this section.

Show the stage-position properties:

```{r}
subset(pic_plane_info, grepl("stage-position", id))
```

> Our motorized stage works in negative coordinate space, as most CNC machines do.
> Take this into account when plotting.

Get the metadata of all images:

```{r}
plane_info_df <- setNames(metamorph_pics, basename(metamorph_pics)) %>% 
  # Get metadata
  lapply(rcell2.cellid::tiff_plane_info) %>% 
  bind_rows(.id="image") %>% 
  # Fix variable names and types
  mutate(variable = make.names(id)) %>% 
  filter(grepl("stage.position", variable)) %>% 
  mutate(value = as.numeric(value)) %>% 
  # Make it wider
  pivot_wider(id_cols = "image", names_from = "variable", values_from = "value")

plane_info_df
```

Plot XY stage positions:

```{r}
ggplot(plane_info_df) +
  geom_point(aes(stage.position.x, stage.position.y))
```

> This plot is specially useful when tracing a path for positions in a many-well time-course experiment.

#### Check position indexes and overlap

The following code match the images' _position_ (Pos) to their microscope stage _physical_ XY coordinates,
which are stored in the TIFF tags of the original images.

It requires the `images` dataframe in `cell.data` to get the file names,
_but_ you could also use `dir` to get the files by pattern, and `sub` to get the position IDs,
independently of CellID.

```{r}
images <- rcell2.cellid::arguments_to_images(arguments = image_list)
```

Add image metadata and replot the stage's "path":

```{r}
# Microscope details.
magnification <- 40 # 40x
ccd_pixel_size_microns <- 6.45 # 6.45 um

# Calculate "Field Of View" size.
fov_size_microns_x <- 1376 * ccd_pixel_size_microns / magnification  # um in the "X/width" direction
fov_size_microns_y <- 1040 * ccd_pixel_size_microns / magnification  # um in the "Y/height" direction

# Plot fields of view to check for overlaps visually.
plt <- plane_info_df %>% 
  left_join(select(images, image, pos, t.frame, channel)) %>% # filter(channel == "TFP") |> 
  arrange(pos) %>% 
  ggplot(aes(stage.position.x, stage.position.y, label = pos)) +
  geom_path(aes(group = t.frame)) +
  geom_rect(aes(xmin=stage.position.x-fov_size_microns_x/2, 
                xmax=stage.position.x+fov_size_microns_x/2, 
                ymin=stage.position.y-fov_size_microns_y/2, 
                ymax=stage.position.y+fov_size_microns_y/2,
                group = pos, fill = factor(pos)), alpha =.5)+
  geom_text(size=10) +
  facet_wrap(t.frame~channel) + guides(fill = "none") +
  scale_x_reverse() + # coord_fixed() +
  ggtitle("Physical stage coordinates v.s. Position index",
          "Compare the index numbers with the expected physical distrubution in the well plate.\nThe shaded areas around index numbers shuould not overlap with each other.")

plt
```

> If any two shaded areas overlap, there will be duplicated cells in the dataset.

We do not yet offer a way to remove them automatically. You may do this yourself
by finding the XY coordinates of the first cells not shared between images, and using
their coordinates to remove the overlaping set from one position.

### Apply FFT filter on BF images

Optionally, use ImageJ's bandpass FFT filter on the defocused brightfield images.

This can help Cell-ID find cells and reduce background artifacts.

There are two ways to apply the filter:

- [Parallel] run: paralellized execution, which is faster and uses more resources (recommended).
- [Sequential] run: one image is processed at a time, which can be slow on large datasets.

#### Sequential

Here is a wrapper that does most of this for you, calling ImageJ headlessly, on all images.

Get the path to the original BF images:

```{r eval=F}
# Choose your own path!
data.dir <- "/path/to/your/data"

# Or use the example images (requires "rcell2.examples", see first example above).
data.dir <- system.file("extdata/sample_datasets/sample_time_series/",
                        package = "rcell2.examples")

# List files
dir(data.dir)
```

List the BF images from the `arguments` function, and symlink them to a separate directory:

```{r eval=F}
# Get image paths
cellid.args <- 
  rcell2.cellid::arguments(path = data.dir,
                           file.pattern = "^(BF|[TRY]FP)_Position(\\d+)_time(\\d+).tif$") %>% 
  filter(pos %in% good.pos)

# Save BF files
bf.files <- cellid.args %>%
  select(bf, path) %>% with(paste0(path,"/",bf)) %>% unique()

# Make a directory to put them in
fft.bfs.subdirectory <- "bf_subset"
fft.bfs.dir <- paste0(new.data.dir, "/", fft.bfs.subdirectory)
dir.create(fft.bfs.dir)

# Link them over
file.symlink(from = normalizePath(bf.files),
             to = paste0(dirname(bf.files[1]), "/", fft.bfs.subdirectory, "/", basename(bf.files)))
```

Run FFT filter on all images sequentially:

```{r eval=F}
# This may take a while...
imagej_fft_filter(pic.path = fft.bfs.dir)
```

Symlink the rest of the images (fluorescence imgs) to the filtered directory:

```{r eval=F}
# Get all files
all.files <- cellid.args %>% 
  with(paste0(path[1],"/", c(bf, image))) %>% unique()
# And the difference with the BF vector
the.rest <- setdiff(all.files, bf.files)
# Symlink over to the directory of the FFT-filtered BFs
if(length(all.files) == length(bf.files) + length(the.rest)){
  file.symlink(from = normalizePath(the.rest),
               to = paste0(dirname(the.rest[1]), "/bf_subset/filtered/", basename(the.rest)))
}
```


#### Parallel

This is the parallel version of the FFT filter script.

List the BF images from the `arguments` function:

```{r eval=F}
# Get image paths
cellid.args <-
  rcell2.cellid::arguments(path = new.data.dir,
                           file.pattern = "^(BF|[TRY]FP)_Position(\\d+)_time(\\d+).tif$") %>% 
  filter(pos %in% positions)
```

Split the BF files by position, and symlink them to different subdirectories:

```{r eval=F}
cellid.args.split <- split(cellid.args, ~pos)

fft.bfs.subdirs <- list()

for(i in seq_along(cellid.args.split)) {
  # Save BF files
  bf.files <- cellid.args.split[[i]] %>%
    select(bf, path) %>% with(paste0(path,"/",bf)) %>% unique()
  
  # Make a directory to put them in
  fft.bfs.subdirectory <- paste0("bf_subset_", i)
  fft.bfs.dir <- paste0(new.data.dir, "/", fft.bfs.subdirectory)
  dir.create(fft.bfs.dir)
  
  # Link them over
  file.symlink(from = normalizePath(bf.files),
               to = paste0(dirname(bf.files[1]), "/", fft.bfs.subdirectory, "/", basename(bf.files)))
  
  fft.bfs.subdirs[i] <- fft.bfs.dir
}

fft.bfs.subdirs
```

Run FFT filter in parallel, with one thread per subdirectory:

```{r eval=F}
n_cores <- parallel::detectCores() #- 1
n_chunks <- length(fft.bfs.subdirs)

# Make cluster
cl <- parallel::makeCluster(
  spec = min(n_chunks,n_cores), 
  setup_strategy = "sequential"  #https://github.com/rstudio/rstudio/issues/6692
)

# This may take a while...
doParallel::registerDoParallel(cl)
foreach(fft.bfs.subdir=fft.bfs.subdirs, .packages = "rcell2.cellid") %dopar% {
  imagej_fft_filter(pic.path = fft.bfs.subdir, imagej.path="~/Software/FIJI/Fiji.app/ImageJ-linux64")
}
parallel::stopCluster(cl)
```

Symlink filtered BFs in each subdirectory to a single "filtered" images directory:

```{r eval=F}
filtered.bfs <- dir(paste0(fft.bfs.subdirs, "/filtered"), full.names = T)

filtered.bfs.dir <- paste0(new.data.dir, "/fft_images_dataset/")
dir.create(filtered.bfs.dir)

result <- file.symlink(from = normalizePath(filtered.bfs), 
                       to = paste0(filtered.bfs.dir, basename(filtered.bfs)))

all(result)  # Check
```

Symlink the rest of the images (fluorescence imgs) to the filtered directory:

```{r eval=F}
# Get all files
fl.files <- cellid.args %>% 
  with(paste0(path, "/", image)) %>% unique()

# Symlink over to the directory of the FFT-filtered BFs
result <- file.symlink(from = normalizePath(fl.files),
                       to = paste0(filtered.bfs.dir, basename(fl.files)))

all(result)  # Check
```

> Done!

You can run CellID using this directory as the `data.dir`:

```{r eval=F}
data.dir <- normalizePath(filtered.bfs.dir)
```

## Segmentation

In this section we will prepare and run Cell-ID.

### Parameters

First we must configure the Cell-ID parameters that affect cell segmentation, 
tracking, and some corrections.

#### Descriptions

Show a data.frame with the description of each Cell-ID parameter:

```{r}
rcell2.cellid::cellid_parameter_descriptions(list_format = F)
```

#### Example parameters

`parameters_default` is a helper function to prepare parameters more easily:

```{r}
parameters.list <- 
  rcell2.cellid::parameters_default(background_reject_factor = 0.8)

parameters.list$max_split_over_minor
```

Parameters must be written to a `parameters.txt` plain text file with the proper syntax,
which Cell-ID will read later on.

For this purpose, you may use the `parameters_write()` function. It writes the parameters,
and returns the path where it was saved.

<!-- Internal note: consider moving this step into cell2() -->
```{r}
parameters.txt <- rcell2.cellid::parameters_write(parameters.list)

parameters.txt
```

Este path es el que hay que pasarle a `arguments()` en la siguiente sección.

Revisemos el contenido del `parameters.txt` que generamos recién:

```{r}
# Mostrar el contenido del archivo
writeLines(readLines(parameters.txt))
```

For clarity, here is a valid, hand-made parameter list, with the same defaults:

```{r eval=F}
parameters.list <- list(
  max_split_over_minor = 0.50,
  max_dist_over_waist = 8.00,
  max_pixels_per_cell = 2000,
  min_pixels_per_cell = 75,
  background_reject_factor = 0.75,
  tracking_comparison = 0.20,
  align_individual_cells = F,
  align_fl_to_bf = T,
  image_type = "brightfield",
  bf_fl_mapping = "list"
  )
```

### Arguments

The `arguments` function outputs a data.frame with information from images, 
which is needed to run Cell-ID.

The key parameter is `file.pattern`, a regular expression used to find image
files in the `data.dir` path.

By default, `arguments` uses:

    "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$"

Enclosed in parentheses are the "capture groups" of the regular expression.
These delimit the parts of the file name which contain identifiers for 

1. Imaging channel (`ch`).
2. Stage position index (`pos`).
3. Time-frame index (`t.frame`).

If your experiment has a single time frame, and it is not part of the file names,
the content of the corresponding capturing group can be deleted (leaving the
empty parentesis in place):

    "^(BF|[A-Z]FP)_Position(\\d+)().tif$"

The regular expression can be used to select or filter out sets of images (
though it will be often easier to use R's tool for this). To select only position
with index "2", and times 2, 3 and 4, use:

    "^(BF|[A-Z]FP)_Position(0*2)_time(0*[423]).tif$"

> Note the `0*` in front of numbers. This indicates that there might me be leading
> zeros in front of the position and time identifiers.

If the identifiers on your file names appear in a different order, either rename them as
shown in the [Renaming images] section, or reorder the default `file.pattern.groups.order`
in the call to `arguments`.

Note, however, that the channel identifier _must_ be first. Cell-ID will use the **first
three letters** to distinguish and group imaging channels.

#### Input file pattern

Adjust file patterns in `rcell2.cellid::arguments`. Go through the function's
help page to learn about its parameters.

The path to the images of your experiment must be alredy defined,
as explained in the [Path to the dataset] section of this notebook.

> **Important**: the patterns used in `arguments` must match the ones used in
> `cell.load.alt` when loading Cell-ID's output (later on).

Original images file pattern examples; choose one and comment the others:

```{r}
# Default value: all channels, no z-stack.
arguments.file.pattern <- "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$"

# To consider z-stacks:
# arguments.file.pattern <- "^(BF|[A-Z]\d+)_Position(\d+)_time(\d+).tif$"

# BF or TFP only, no t.frame info.
# arguments.file.pattern <- "^(BF|TFP)_Position(\\d+)().tif$"
```

#### Usage example

Check that image file names are properly recognized:

```{r}
cellid.args <- rcell2.cellid::arguments(data.dir,
                                        file.pattern = arguments.file.pattern,
                                        parameters = parameters.txt)  # Parameters are specified here.

cellid.args
```

Yo may filter out or select certain image sets at this stage:

```{r}
cellid.args %>% filter(pos == 2, t.frame %in% c(4,2,3))
```

#### Nuclear or Vacuolar tags

Images containing the location of the nucleus or vacuole can be used
to derive extra measurements from those structures.

A "third" image list must be added to the arguments. In the following example,
the YPF channel is added to the arguments to a new column named "`third`" exactly.

```{r}
# Optionally Add "third" column
cellid.args <-  left_join(
  cellid.args,
  cellid.args %>% filter(ch == "YFP") %>% select(pos, t.frame, image) %>% rename(third = image)
)
```

The `cell2` function will look for this column and pass the images to Cell-ID if found.

To enable this feature in Cell-ID, the parameters must have been 
also configured (see `?parameters_default`) by setting `third_image` to
"vacuole_label" or "nuclear_label".

### Preview images in ImageJ

No analysis package exists (yet) that can replace a researcher's general visual assesment.

This section helps you open your images with FIJI-ImageJ before you begin.

A simple Macro can be run in ImageJ to load virtual hyperstacks of any experiment.

> Note: this macro uses a "file" pattern that only matches input images (and not ".out")
> in a tipically-named set of images.

Steps:

1. Run the following code, copy its output to the clipboard.
2. Open ImageJ/FIJI, and open a new "Macro" window by clicking on "Plugins -> New -> Macro".
3. Paste the macro into the macro editor, and click on "Run". A new hyperstack window will open.
4. Browse the images using the sliders.

```{r}
# Make an ImageJ macro to browse the images before segmentation
n_axis1 <- length(unique(cellid.args$t.frame))
n_axis2 <- length(unique(cellid.args$pos))
n_axis3 <- length(unique(cellid.args$ch))

# Add 1 to include the BF images as a possible channel
n_axis3 <- n_axis3 + 1

macro <- glue::glue(
  '// Macro',
  'run("Image Sequence...", "open={data.dir} file=(.*\\\\d.tif$) sort use");',
  'run("Stack to Hyperstack...", "order=xyczt(default) channels={n_axis1} slices={n_axis2} frames={n_axis3} display=Grayscale");',
  .sep = "\n"
)

cat(macro)
```

> Note: the dimensions names may be mismatched between R and the macro. This is because 
virtual stacks must be in `xyczt` order (time is likely to end up as the "channels" dimension), 
but the order in which the "Image Sequence..." is loaded depends on how their files are named.

The only restriction of this approach is that only "3" dimensions are available for
browsing: `frame`, `plane`, and `channel`. This is relevant if you wish to browse
segmentation results (which adds another dimension to the set: original vs "out").
A fourth dimension would be needed, but Hyperstacks only provide 3. Alternatively, 
open another virtual hyperstack for the output images, and browse them in-sync.

<!-- Si alguien sabe como reordenar fotos en un stack, que avise. Creo que se puede ¿reslice? ¿algo asi? -->

### Run Cell-ID

The `cell2` function generates system commands to run Cell-ID,
and executes them in parallel by default.

The `cell.command` argument must be the path to the Cell-ID binary executable.
In this version of `rcell2`, it defaults to `NULL`, and the intenal executable 
is used.

Warning: existing output files **will be overwritten**. To check if this will happen 
before running `cell2`, run "`arguments_check(cellid.args)`".

```{r eval=F}
cell2.result <- rcell2.cellid::cell2(arguments = cellid.args,
                                     n_cores = 2)
```

> Run `?cell2` to learn about advanced segmentation parameters, and to generate additional
output files with segmentation masks or identified cell-boundary pixel coordinates.

> `n_cores` can be set to the number of CPU cores you want to use to parallelize
> the segmentation (relying on `foreach`). It defaults to use all but one of the
> available cores.

### Output data

Cell-ID's output consists mainly of:

* Segmented images (named with the `.out.tif` posfix).
  * *Optional:* "BF.out" with identified binary masks.
* Tables with single-cell quantitative information (from their morphology and fluorescence).
  * *Optional:* Tables with the boundary and interior pixels of identified cell.

#### Output file pattern

File patterns for the image set may vary slightly; depending on what images were 
provided as input, and the identifiers in their file names.

The pattern must match file names of fluorescent images, and have a capturing group
for the channel identifier (e.g. `YFP`, `GFP`, etc.).

The most common fluorescent channel patterns for `cell.load.alt` and `parameter_scan`
are defined below.

Choose one pattern and comment the others:

```{r}
# Default value: all fluorescent tags, including Z-stack fluorescence channels.
fluorescence.pattern <- "^([GCYRT]FP|[GCYRT]\\d+)_Position\\d+_time\\d+.tif$"

# Default: add "BF" as a possible channel (when CellID was run with bf_as_fl=TRUE)
# fluorescence.pattern <- "^([GCYRT]FP|[GCYRT]\\d+|BF)_Position\\d+_time\\d+.tif$"

# Same as defualt, but without t.frame information.
# fluorescence.pattern <- "^([GCYRT]FP|[GCYRT]\\d+)_Position\\d+.tif$"
```

List files that match the pattern, to check that it works as expected:

```{r}
data.dir %>% 
  dir(pattern = fluorescence.pattern)
```

#### Load the output

The output tables can be loaded with `cell.load.alt`.

```{r eval=F}
# Load output
cell.data <- rcell2.cellid::cell.load.alt(path = data.dir,
                                          fluorescence.pattern=fluorescence.pattern)
```

> Note: your `fluorescence.pattern` regex may vary (read the [Output file pattern] section above).

Alternatively, function `load_cell_data` from `rcell2` can load those tables as well.

```{r eval=F}
# Install rcell2's main analysis package if unavailable.
if(!requireNamespace("rcell2")){
   devtools::install_github("darksideoftheshmoo/rcell2")
}

# Load output
cell_data <- rcell2::load_cell_data(path = data.dir)
```

Both `rcell2.cellid` and `rcell2` provide the `cell.load.boundaries` function, which can 
load the cell boundaries and interior pixels coordinates.

This data is only available if either `output_coords_to_tsv` or `encode_cellID_in_pixels` 
were set to `TRUE` when Cell-ID was run.

To load the boundary pixels, use the `cell.load.boundaries` function. It can load this 
information from two kinds of sources:

* "`masks.tsv`": from TSV files, available if Cell-ID was run with `output_coords_to_tsv=TRUE`.
* "`out.tif`": from binary masks in TIFF files, available if Cell-ID was run with `encode_cellID_in_pixels=TRUE`.

```{r eval=F}
# Useful if either "output_coords_to_tsv" or "encode_cellID_in_pixels" were TRUE in cell().
cell.boundaries <- 
  rcell2::cell.load.boundaries(data.source = "masks.tsv",
                               arguments = cellid.args,
                               pixel.type = "b")
```

#### Variable descriptions

To help understand CellID's output, we documented the descriptions of variables
in `cell.data$data`. They are available through a function:

```{r}
rcell2.cellid::cellid_output_descriptions(list.output = F)
```

The 

### Tuning parameters

Sometimes we want to test out many parameter combinations 
before running Cell-ID in the full dataset.

This functionality requires the `magick` R package,
and ImageMagick on your system (which can be obtained 
[here](https://imagemagick.org/script/download.php)). 

Run the following to install the R package if absent:

```{r}
if(!requireNamespace("magick")){
  install.packages("magick")
}
```

#### Example setup

Define working paths for parameter testing:

* `data.dir`: directory with the original images (they will not be modified).
* `test.dir`: directory for temporary files of the tuning process.

```{r}
# Use the example images or set your own path
data.dir <- system.file("extdata/sample_datasets/sample_time_series/",
                        package = "rcell2.examples")

# The output of the parameter scan will be saved here:
test.dir <- "/tmp/images_directory/test.dir"
```

Setup arguments and patterns as usual (if not done already):

```{r}
# Default value: all channels, no z-stack.
arguments.file.pattern <- "^(BF|[A-Z]FP)_Position(\\d+)_time(\\d+).tif$"

# Get full image list
cellid.args <- rcell2.cellid::arguments(data.dir,
                                        file.pattern = arguments.file.pattern)
```

#### Image set

Choose which image sets in `cellid.args` you wish to use for the parameter scan.

For example, choose some *positions* (image sets) and *t.frame*s (time frames)
to restrict the image test set to only some of them.

```{r}
# Choose test positions, frames and channels.
test.pos = unique(cellid.args$pos)[1]        # e.g.: One position.
test.frames = unique(cellid.args$t.frame)[1] # e.g.: One frame.
test.chs = unique(cellid.args$ch)[1]         # e.g.: One channel.

# Filter cellid.args to choose image sets for the scan
scan.arguments <-  
  subset(cellid.args, 
         pos %in% test.pos & t.frame %in% test.frames)

# Examine the subset
scan.arguments
```

#### Parameter combinations

For each parameter variation, we need a new parameters file.

In this example, only `background_reject_factor` is scanned, across 4 values:

```{r}
parameters.list <- rcell2.cellid::parameters_default(
  background_reject_factor = seq(from=0, to=1.5, by = 0.4)
)

parameters.list$background_reject_factor
```

The parameters list must now be expanded into a data.frame, 
with a row for every possible combination of parameter values:

```{r}
parameters.df <- expand.grid(parameters.list)

parameters.df
```

> Note: You might want to select some rows from that table. In that case, simply filter it.

#### Automatic scan

> Now comes the magic part.

The `parameter_scan` function uses temporary directories to work on images, 
and avoids messing up the main data directory, 
while running CellID in parallel for each parameter variation.

Just run:

```{r eval=F}
scan.results <- 
  parameter_scan(parameters.df = parameters.df,
                 # Optionally choose the temporary output directory by setting "test.dir".
                 scan.arguments = scan.arguments)
```

> Have a look at the function's source code if you like, its hopefully well commented.

#### Plot summary

A few "summary" quantities are calculated for each run:

* `fft`
* `el.p`
* `ucids`
* `persistence`
* `roughness`
* `roughness2`

The average of these quantities may be useful for selecting optimal parameters.

A few of combinations these are plotted below.

First get the output dataframe:

```{r}
results.bound <- scan.results$results.bound
```

A few plots:

```{r}
results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(persistence, el.p/fft, label = id,
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. frames per cell (persistence) VS 'el.p/fft' per parameter variation") +
  theme_minimal() + scale_color_discrete()

results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(persistence, el.p/fft, label = id,
                 color = as.ordered(max_split_over_minor)),
             alpha = .7, fill = "NA") +
  ggtitle("Avg. frames per cell (persistence) VS 'el.p/fft' per parameter variation") +
  theme_minimal() + scale_color_discrete()
```

<!-- Internal note: TO-DO: add explanations of these quantitites. -->

More plots:

```{r}
results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(el.p, fft, label = id,
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. el.p VS Avg. fft.stat per parameter variation") +
  theme_minimal() + scale_color_discrete()

results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(roughness, persistence, label = paste0(id, "=", background_reject_factor),
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. roughness per cell VS Avg. frames per cell (persistence) per parameter variation") +
  theme_minimal() + scale_color_discrete()

results.bound %>% filter(channel == "BF.out", t.frame == 0) %>% 
  left_join(parameters.df %>% mutate(id = 1:n()), by = "id") %>% 
  ggplot() +
  geom_label(aes(roughness2, persistence, label = paste0(id, "=", background_reject_factor),
                 color = as.ordered(background_reject_factor))) +
  ggtitle("Avg. roughness2 per cell VS Avg. frames per cell (persistence) per parameter variation") +
  theme_minimal() + scale_color_discrete()
```

<!-- Internal note: TO-DO: add explanations of these quantitites. -->

#### Review result in ImageJ

Make TIFF stacks for a one or more imaging channels, with the `make_scan_stacks` function.

To help the user choose a parameter set, the stacks are annotated with the parameters used
for the segmentation, and other metadata (position, time frame, and channel).

A copy-paste-ready ImageJ Macro will be printed out, 
to easily load the stacks as virtual Hyperstacks in ImageJ.

```{r eval=F}
stack.paths <- 
  make_scan_stacks(scan.results = scan.results, 
                   stack.channels = "BF.out")
```

> Have a look at the function's source code if you like, its hopefully well commented.

Copy paste the macro to a new macro window in ImageJ, and hit run!
The stack should be loaded automagically.

Paths and macros are saved in the output:

```{r}
names(stack.paths)
```

```{r}
stack.paths$stack.paths
```

```{r}
stack.paths$imagej.macros
```

#### Final parameter set

This parameter set was chosen for FFT-filtered BFs.

Under 0.8 background_reject_factor, there were some "persisten" _ghosts_;
elongated _chorizos_ on the sides of cells.

```{r eval=F}
parameters.list <- rcell2.cellid::parameters_default(
  background_reject_factor = 0.8,
  max_split_over_minor = 0.6,
  max_dist_over_waist = 6,
  max_pixels_per_cell = 3500,
  treat_brightfield_as_fluorescence_also = T
)
```

<!-- TODO: nombrar los stacks por parameter modificado -->

## Data analysis

Helping with data analysis is `rcell2`'s purpose.

Installation instructions for `rcell2` and `rcell2.magick` packages can be found [here](https://github.com/darksideoftheshmoo/rcell2#installing-the-package) and [here](https://github.com/darksideoftheshmoo/rcell2-magick#installing-the-package),
respectively.
