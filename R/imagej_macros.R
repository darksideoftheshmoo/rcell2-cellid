#' Make an ImageJ macro to browse the images before segmentation
#' 
#' Due to an order restriction on ImageJ Virtual Hyperstacks, t.frame is mapped to "Channel", position is mapped to "Slice", and channel is mapped to "frames".
#' 
#' The function writes a macro to a temp
#' 
#' @param images The "images" dataframe, as loaded by get_cell_data, load_cell_data, or as generated by arguments_to_images from arguments.
#' @param use_out Wether to use original images (FALSE/0), the segmented output (TRUE/1), or both (0:1).
#' @param macro_file Write the macro to temporary file/directory. Else, a path to the file where to save the macro.
#' @param fix_order Symlink images to a temporary directory with new file names. The new sorting order will make images appear with the correct channel-slice-frame mapping in ImageJ.
#' @param add_tools Add commands to the macro that open handy tools (e.g. for tagging events in single cells, adjusting brightness, etc.).
#' @export
ijm_open_hyperstack <- function(images, use_out = 0:1, macro_file=TRUE, fix_order=TRUE, add_tools=TRUE){
  # Check arguments.
  if(!all(use_out %in% 0:1) | length(use_out) > 2) 
    stop("Error: use_out can only be TRUE, FALSE, an array of both, or their integer representations (0, 1).")
  
  if(fix_order){
    # Temporary directory for renamed symlinks
    img.dir <- file.path(tempdir(check = T), "ijm_set")
    try(unlink(img.dir, recursive = T), silent = T)
    dir.create(img.dir, showWarnings = F)
    # Rearrange images
    exp.images <- images %>%
      dplyr::filter(is.out %in% use_out) |> select(-image, -path) |> dplyr::rename(original.file = file) |> 
      mutate(path = img.dir) |> 
      mutate(channel = ifelse(is.out, paste0(channel, ",out"), channel)) |> 
      mutate(image = paste0("time-", t.frame, "-pos-", pos, "-ch-", channel, ".tif")) |> 
      unite(file, path, image, sep = .Platform$file.sep, remove = F)
    # Link images to new tmp dir
    res <- file.symlink(from = exp.images$original.file, to = exp.images$file)
    # Get axes
    n_axis1_c <- exp.images %>% filter(is.out %in% use_out) %>% with(unique(channel)) %>% length()
    n_axis2_s <- exp.images %>% filter(is.out %in% use_out) %>% with(unique(pos)) %>% length()
    n_axis3_f <- exp.images %>% filter(is.out %in% use_out) %>% with(unique(t.frame)) %>% length()
  } else {
    # Just use the original images
    exp.images <- images
    # Get dir
    img.dir <- exp.images$path[1]
    # Get axes
    n_axis1_c <- exp.images %>% filter(is.out %in% use_out) %>% with(unique(t.frame)) %>% length()
    n_axis2_s <- exp.images %>% filter(is.out %in% use_out) %>% with(unique(pos)) %>% length()
    n_axis3_f <- exp.images %>% filter(is.out %in% use_out) %>% with(unique(channel)) %>% length()
  }
  
  
  # Check
  stopifnot((n_axis1_c * n_axis2_s * n_axis3_f) ==  nrow(unique(filter(exp.images, is.out %in% use_out))))
  
  if(isTRUE(as.logical(use_out))) 
    import_command <- 'run("Image Sequence...", "open={img.dir} file=(.*out.tif$) sort use");'
  else if(isFALSE(as.logical(use_out))) 
    import_command <- 'run("Image Sequence...", "open={img.dir} file=(.*(?!out).tif$) sort use");'
  else 
    import_command <- 'run("Image Sequence...", "open={img.dir} file=(.*.tif$) sort use");'
  
  # Build macro.  
  macro <- glue::glue(
    '// Macro',
    import_command,
    'run("Stack to Hyperstack...", "order=xyczt(default) channels={n_axis1_c} slices={n_axis2_s} frames={n_axis3_f} display=Grayscale");',
    .sep = "\n"
  )
  
  # Add tools
  tools <- paste('// Additional tools:',
                 'run("Channels Tool...");',
                 'run("Brightness/Contrast...");',
                 'setTool("multipoint");',
                 'run("Point Tool...");',
                 sep = "\n")
  if(add_tools) macro <- paste(macro, tools, sep = "\n")
  
  # Print the macro.
  cat(macro)
  cat("\n\n")
  
  # Only try writing to the file if "macro_file" is not false.
  if(!isFALSE(macro_file)){
    
    # Make up a new path if it was not provided.
    if(!is.character(macro_file)){
      macro_file <- tempfile(tmpdir = tempdir(), fileext = ".ijm")
    }
    
    # Write the macro.
    write(macro, file = macro_file)
  }
  
  # Return invisibly.
  return(invisible(macro_file))
}

#' ImageJ macro to open ".out" files as a virtual hyperstack
#' 
#' Use this function to quickly inspect the result of the segmentation in ImageJ/FIJI.
#' 
#' @param cellid.args The "arguments" data frame, as produced by \code{rcell2.cellid::arguments}.
#' @inheritDotParams ijm_open_hyperstack
#' @export
ijm_open_segmentation <- function(cellid.args, ...){
  
  result <- cellid.args |> 
    arguments_to_images() |>
    ijm_open_hyperstack(...)
  
  return(result)
}

#' Run ImageJ FFT filter macro from R
#' 
#' Passes an ImageJ FFT filter on files matching \code{BF.*.tif} in the target directory.
#' 
#' The modified images are saved to a new subdirectory with default name: "filtered/" (hardcoded in the macro).
#' 
#' Run \code{???imagej_macro_run} for more info.
#' 
#' @param pic.path Path to the directory containing the image files (passed as extra.args to imagej_macro_run).
#' @inheritParams imagej_macro_run
#' @inheritDotParams imagej_macro_run
#' @export
#' 
imagej_fft_filter <- function(
  pic.path,
  script.path = system.file(file.path("imagej_macros", "FFT_filter_on_BFs_R.txt"),
                            package = "rcell2.cellid"),
  ...
  ){
  
  is.dir <- file.info(pic.path)$isdir
  
  if(is.dir) {
    pic.path <- paste0(normalizePath(pic.path), .Platform$file.sep)
  } else {
    stop("The provided 'pic.path' is not a directory.")
  }
  
  imagej_macro_run(script.path = script.path, extra.args = pic.path, ...)
}

# #' Run ImageJ open on a path
# #' 
# #' @param pic.path Path to the image file.
# #' @inheritParams imagej_macro_run.headless
# #' @export
# #' 
# imagej.open <- function(
#   pic.path,
#   script.path = system.file("inst/imagej_macros/open.ijm", 
#                             package = "rcell2"),
#   wait = F){
#   
#   is.dir <- file.info(pic.path)$isdir
#   
#   if(!is.dir) {
#     pic.path <- paste0(normalizePath(pic.path))
#   } else {
#     stop("The provided 'pic.path' is a directory.")
#   }
#   
#   imagej_macro_run(script.path, pic.path)
# }


#' Run headless ImageJ Macro file
#' 
#' The macro program takes one argument: a path to a directory containing images matching the pattern "BF.*.out.tif".
#' 
#' Images are then proceesed with ImageJ's "Bandpass filter" and the output is saved to a subdirectory named "filtered".
#' 
#' @param imagej.path Path to the ImageJ binary (a path to "ImageJ-linux64" or equivalent).
#' @param script.path Path to the ImageJ macro. Defaults to built-in macro.
#' @param extra.args A string with extra arguments to the ImageJ command, pasted at the end.
#' @param headless Wether ImageJ should be run headlessly (no GUI).
#' @inheritParams base::system
#' 
imagej_macro_run <- function(
  script.path,
  imagej.path = "~/Software/FIJI/Fiji.app/ImageJ-linux64",
  wait = T, 
  headless = T,
  extra.args = ""){
  command <- paste(
    normalizePath(imagej.path),
    {if (headless) "--headless -macro" else "-macro"},
    normalizePath(script.path),
    extra.args
  )
  
  base::system(command, wait = wait)
}

