#' Make an ImageJ macro to browse the images before segmentation
#' 
#' Due to an order restriction on ImageJ Virtual Hyperstacks, t.frame is mapped to "Channel", position is mapped to "Slice", and channel is mapped to "frames".
#' 
#' The function writes a macro to a temp
#' 
#' @param images The "images" dataframe, as loaded by cell.load.alt, load_cell_data, or as generated by arguments_to_images from arguments.
#' @param use_out Wether to look for original images, or the segmented output.
#' @param macro_file TRUE: write to temporary file/directory. FALSE: do not write macro to a file. Else, a path to the file where to save the macro.
#' @export
ijm_open_hyperstack <- function(images, use_out = FALSE, macro_file=TRUE){
  n_axis1 <- images %>% filter(is.out == use_out) %>% with(unique(t.frame)) %>% length()
  n_axis2 <- images %>% filter(is.out == use_out) %>% with(unique(pos)) %>% length()
  n_axis3 <- images %>% filter(is.out == use_out) %>% with(unique(channel)) %>% length()
  
  # Check
  stopifnot((n_axis1 * n_axis2 * n_axis3) ==  nrow(unique(filter(images, is.out == use_out))))
  
  # Get dir
  img.dir <- images$path[1]
  
  macro <- glue::glue(
    '// Macro',
    if(use_out) 'run("Image Sequence...", "open={img.dir} file=(.*out.tif$) sort use");'
    else 'run("Image Sequence...", "open={img.dir} file=(.*\\\\d.tif$) sort use");',
    'run("Stack to Hyperstack...", "order=xyczt(default) channels={n_axis1} slices={n_axis2} frames={n_axis3} display=Grayscale");',
    .sep = "\n"
  )
  
  cat(macro)
  cat("\n\n")
  
  if(isFALSE(macro_file))
    return(invisible())
  
  if(isTRUE(macro_file))
    macro_file <- tempfile(tmpdir = tempdir(), fileext = ".ijm")
    
  write(macro, file = macro_file)
  
  return(macro_file)
}

#' Run ImageJ FFT filter macro from R
#' 
#' Passes an ImageJ FFT filter on files matching \code{BF.*.tif} in the target directory.
#' 
#' The modified images are saved to a new subdirectory with default name: "filtered/" (hardcoded in the macro).
#' 
#' Run \code{???imagej_macro_run} for more info.
#' 
#' @param pic.path Path to the directory containing the image files (passed as extra.args to imagej_macro_run).
#' @inheritParams imagej_macro_run
#' @inheritDotParams imagej_macro_run
#' @export
#' 
imagej_fft_filter <- function(
  pic.path,
  script.path = system.file("imagej_macros/FFT_filter_on_BFs_R.txt", 
                            package = "rcell2.cellid"),
  ...
  ){
  
  is.dir <- file.info(pic.path)$isdir
  
  if(is.dir) {
    pic.path <- paste0(normalizePath(pic.path), "/")
  } else {
    stop("The provided 'pic.path' is not a directory.")
  }
  
  imagej_macro_run(script.path = script.path, extra.args = pic.path, ...)
}

# #' Run ImageJ open on a path
# #' 
# #' @param pic.path Path to the image file.
# #' @inheritParams imagej_macro_run.headless
# #' @export
# #' 
# imagej.open <- function(
#   pic.path,
#   script.path = system.file("inst/imagej_macros/open.ijm", 
#                             package = "rcell2"),
#   wait = F){
#   
#   is.dir <- file.info(pic.path)$isdir
#   
#   if(!is.dir) {
#     pic.path <- paste0(normalizePath(pic.path))
#   } else {
#     stop("The provided 'pic.path' is a directory.")
#   }
#   
#   imagej_macro_run(script.path, pic.path)
# }


#' Run headless ImageJ Macro file
#' 
#' The macro program takes one argument: a path to a directory containing images matching the pattern "BF.*.out.tif".
#' 
#' Images are then proceesed with ImageJ's "Bandpass filter" and the output is saved to a subdirectory named "filtered".
#' 
#' @param imagej.path Path to the ImageJ binary (a path to "ImageJ-linux64" or equivalent).
#' @param script.path Path to the ImageJ macro. Defaults to built-in macro.
#' @param extra.args A string with extra arguments to the ImageJ command, pasted at the end.
#' @param headless Wether ImageJ should be run headlessly (no GUI).
#' @inheritParams base::system
#' 
imagej_macro_run <- function(
  script.path,
  imagej.path = "~/Software/FIJI/Fiji.app/ImageJ-linux64",
  wait = T, 
  headless = T,
  extra.args = ""){
  command <- paste(
    normalizePath(imagej.path),
    {if (headless) "--headless -macro" else "-macro"},
    normalizePath(script.path),
    extra.args
  )
  
  base::system(command, wait = wait)
}

