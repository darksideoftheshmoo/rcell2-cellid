#' Make an ImageJ macro to browse the images before segmentation
#' 
#' Due to an order restriction on ImageJ Virtual Hyperstacks, t.frame is mapped to "Channel", position is mapped to "Slice", and channel is mapped to "frames".
#' 
#' The function writes a macro to a temp
#' 
#' @param images The "images" dataframe, as loaded by cell.load.alt, load_cell_data, or as generated by arguments_to_images from arguments.
#' @param use_out Wether to use original images (FALSE/0), the segmented output (TRUE/1), or both (0:1).
#' @param macro_file TRUE: write to temporary file/directory. FALSE: do not write macro to a file. Else, a path to the file where to save the macro.
#' @param fix_order Symlinks images in a temporary directory using new file names, that will be displayed with the correct channel-slice-frame mapping in ImageJ.
#' @export
ijm_open_hyperstack <- function(images, use_out = 0:1, macro_file=TRUE, fix_order=TRUE){
  
  if(fix_order){
    # Temporary directory for renamed symlinks
    img.dir <- tempdir(check = T) |> paste0("/ijm_set/")
    try(unlink(img.dir, recursive = T), silent = T)
    dir.create(img.dir, showWarnings = F)
    # Rearrange images
    exp.images <- images %>%
      filter(is.out %in% use_out) |> select(-image, -path) |> dplyr::rename(original.file = file) |> 
      mutate(path = img.dir) |> 
      mutate(image = paste0("time-", t.frame, "-pos-", pos, "-ch-", channel, ".tif")) |> 
      unite(file, path, image, sep = "/", remove = F)
    # Link images to new tmp dir
    res <- file.symlink(exp.images$original.file, to = exp.images$file)
    # Get axes
    n_axis1_c <- exp.images %>% filter(is.out %in% use_out) %>% with(unique(channel)) %>% length()
    n_axis2_s <- exp.images %>% filter(is.out %in% use_out) %>% with(unique(pos)) %>% length()
    n_axis3_f <- exp.images %>% filter(is.out %in% use_out) %>% with(unique(t.frame)) %>% length()
  } else {
    # Just use the original images
    exp.images <- images
    # Get dir
    img.dir <- exp.images$path[1]
    # Get axes
    n_axis1_c <- exp.images %>% filter(is.out %in% use_out) %>% with(unique(t.frame)) %>% length()
    n_axis2_s <- exp.images %>% filter(is.out %in% use_out) %>% with(unique(pos)) %>% length()
    n_axis3_f <- exp.images %>% filter(is.out %in% use_out) %>% with(unique(channel)) %>% length()
  }
  
  
  # Check
  stopifnot((n_axis1_c * n_axis2_s * n_axis3_f) ==  nrow(unique(filter(exp.images, is.out %in% use_out))))
  
  macro <- glue::glue(
    '// Macro',
    if(isTRUE(use_out)) 'run("Image Sequence...", "open={img.dir} file=(.*out.tif$) sort use");'
    else if(isFALSE(use_out)) 'run("Image Sequence...", "open={img.dir} file=(.*(?!out).tif$) sort use");'
    else 'run("Image Sequence...", "open={img.dir} file=(.*.tif$) sort use");',
    'run("Stack to Hyperstack...", "order=xyczt(default) channels={n_axis1_c} slices={n_axis2_s} frames={n_axis3_f} display=Grayscale");',
    .sep = "\n"
  )
  
  cat(macro)
  cat("\n\n")
  
  if(isFALSE(macro_file))
    return(invisible())
  
  if(isTRUE(macro_file))
    macro_file <- tempfile(tmpdir = tempdir(), fileext = ".ijm")
  
  write(macro, file = macro_file)
  
  return(macro_file)
}


#' Run ImageJ FFT filter macro from R
#' 
#' Passes an ImageJ FFT filter on files matching \code{BF.*.tif} in the target directory.
#' 
#' The modified images are saved to a new subdirectory with default name: "filtered/" (hardcoded in the macro).
#' 
#' Run \code{???imagej_macro_run} for more info.
#' 
#' @param pic.path Path to the directory containing the image files (passed as extra.args to imagej_macro_run).
#' @inheritParams imagej_macro_run
#' @inheritDotParams imagej_macro_run
#' @export
#' 
imagej_fft_filter <- function(
  pic.path,
  script.path = system.file("imagej_macros/FFT_filter_on_BFs_R.txt", 
                            package = "rcell2.cellid"),
  ...
  ){
  
  is.dir <- file.info(pic.path)$isdir
  
  if(is.dir) {
    pic.path <- paste0(normalizePath(pic.path), "/")
  } else {
    stop("The provided 'pic.path' is not a directory.")
  }
  
  imagej_macro_run(script.path = script.path, extra.args = pic.path, ...)
}

# #' Run ImageJ open on a path
# #' 
# #' @param pic.path Path to the image file.
# #' @inheritParams imagej_macro_run.headless
# #' @export
# #' 
# imagej.open <- function(
#   pic.path,
#   script.path = system.file("inst/imagej_macros/open.ijm", 
#                             package = "rcell2"),
#   wait = F){
#   
#   is.dir <- file.info(pic.path)$isdir
#   
#   if(!is.dir) {
#     pic.path <- paste0(normalizePath(pic.path))
#   } else {
#     stop("The provided 'pic.path' is a directory.")
#   }
#   
#   imagej_macro_run(script.path, pic.path)
# }


#' Run headless ImageJ Macro file
#' 
#' The macro program takes one argument: a path to a directory containing images matching the pattern "BF.*.out.tif".
#' 
#' Images are then proceesed with ImageJ's "Bandpass filter" and the output is saved to a subdirectory named "filtered".
#' 
#' @param imagej.path Path to the ImageJ binary (a path to "ImageJ-linux64" or equivalent).
#' @param script.path Path to the ImageJ macro. Defaults to built-in macro.
#' @param extra.args A string with extra arguments to the ImageJ command, pasted at the end.
#' @param headless Wether ImageJ should be run headlessly (no GUI).
#' @inheritParams base::system
#' 
imagej_macro_run <- function(
  script.path,
  imagej.path = "~/Software/FIJI/Fiji.app/ImageJ-linux64",
  wait = T, 
  headless = T,
  extra.args = ""){
  command <- paste(
    normalizePath(imagej.path),
    {if (headless) "--headless -macro" else "-macro"},
    normalizePath(script.path),
    extra.args
  )
  
  base::system(command, wait = wait)
}

